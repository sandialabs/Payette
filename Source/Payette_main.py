#!/usr/bin/env python

"""
   Main Payette file.  None of the functions in this file should be called
   directly, but only through the executable scripts in
   $PAYETTE_ROOT/Toolset
"""
from __future__ import print_function
import sys
import imp
import os
import pickle
import optparse
import time
import shutil
import datetime
import multiprocessing as mp
from linecache import getline
from shutil import copyfile,rmtree
import subprocess as sbp

try: from Payette_config import *
except ImportError:
    logerr("Payette_config.py must be autogenerated "
           "by config.py before using Payette")
    sys.exit(100)
    pass

from Source.Payette_utils import *

def runPayette(argc,argv):

    global opts,restart,user_input_dict

    # *************************************************************************
    # -- command line option parsing
    usage = "usage: runPayette [options] <input file>"
    parser = optparse.OptionParser(usage = usage, version = "runPayette 1.0")
    parser.add_option("--clean",
                      dest = "clean",
                      action = "store_true",
                      default = False,
                      help = ("Clean Payette auxilary output and exit "
                      "[default: %default]"))
    parser.add_option("--cleanall",
                      dest = "cleanall",
                      action = "store_true",
                      default = False,
                      help = "Clean ALL Payette output and exit [default: %default]")
    parser.add_option("--cchar",
                      dest = "cchar",
                      action = "store",
                      default = None,
                      help = ("Additional comment characters for input file "
                              "[default: %default]"))
    parser.add_option("-d","--debug",
                      dest = "debug",
                      action = "store_true",
                      default = False,
                      help = "Global debug flag [default: %default]")
    parser.add_option("--input-str",
                      dest = "inputstr",
                      action = "store",
                      default = None,
                      help = ("Input string for simulation instead of file "
                              "[default: %default]"))
    parser.add_option("-j","--nproc",
                      dest = "nproc",
                      type = int,
                      default = 1,
                      action = "store",
                      help="Number of simultaneous jobs [default: %default]")
    parser.add_option("-k","--keep",
                      dest = "keep",
                      action = "store_true",
                      default = False,
                      help = ("Do not overwrite old output files with each run "
                              "[default: %default]"))
    parser.add_option("-m","--materials",
                      dest = "mtls",
                      default = False,
                      action = "store_true")
    parser.add_option("--no-restart",
                      dest = "norestart",
                      action = "store_true",
                      default = False,
                      help = "Do not save restart files [default: %default]")
    parser.add_option("--no-writeprops",
                      dest = "nowriteprops",
                      action = "store_true",
                      default = False,
                      help = "Do not write checked parameters [default: %default]")
    parser.add_option("-p","--princ",
                      dest = "principal",
                      action = "store_true",
                      default = False,
                      help = ("Diagonalize input arguments and run problem in "
                              "principal coordinates [default: %default]"))
    parser.add_option("--proportional",
                      dest = "proportional",
                      action = "store_true",
                      default = False,
                      help = ("Use proportional loading for prescribed stress"
                              "components. [default: %default]"))
    parser.add_option("-s","--strict",
                      dest = "strict",
                      action = "store_true",
                      default = False,
                      help = ("Do not use approximations to update kinematic "
                              "quantities (slow) [default: %default]"))
    parser.add_option("-S","--sqa",
                      dest = "sqa",
                      action = "store_true",
                      default = False,
                      help = ("Run additional verification/sqa checks "
                              "[default: %default]"))
    parser.add_option("-t",
                      dest = "timing",
                      action = "store_true",
                      default = False,
                      help = ("time execution of Payette runs [default: %default]"))
    parser.add_option("-T","--use-table",
                      dest = "use_table",
                      action = "store_true",
                      default = False,
                      help = ("Update kinematic quantities from input when "
                              "applicable [default: %default]"))
    parser.add_option("--test-restart",
                      dest = "testrestart",
                      action = "store_true",
                      default = False,
                      help = "Test restart capabilities [default: %default]")
    parser.add_option("-v","--verbosity",
                      dest = "verbosity",
                      type = "choice",
                      choices = ["0","1","2","3","4"],
                      default = "3",
                      action = "store",
                      help = "Verbosity default: %default]")
    parser.add_option("-w","--write-vandd",
                      dest = "write_vandd_table",
                      action = "store_true",
                      default = False,
                      help = ("Write equivalent velocity and displacement table "
                              "[default: %default]"))
    (opts,args) = parser.parse_args(argv)

    if not os.path.isfile(Payette_Materials_File):
        logerr("buildPayette must be run to generate "
               "Source/Materials/Payette_installed_materials.py")
        sys.exit(130)
        pass

    # @tjf: restart is temporarily disabled

    opts.norestart = True
    payette_exts = [".log",".math1",".math2",".props",".echo",".prf"]
    if opts.cleanall:
        payette_exts.extend([".out"])
        opts.clean = True

    if opts.clean:
        cleaned = False
        # clean all the payette output and exit
        for arg in args:
            argdir,argbas = os.path.split(os.path.realpath(arg))
            argnam,argext = os.path.splitext(arg)
            if argnam not in [os.path.splitext(x)[0] for x in os.listdir(argdir)]:
                logwrn("no Payette output for {0} found in {1}"
                       .format(arg,argdir))
                continue
            loginf("cleaning output for {0}".format(argnam))
            for ext in payette_exts:
                try:
                    os.remove( argnam + ext)
                    cleaned = True
                except: pass
                continue
            continue
        msg = "INFO: output cleaned" if cleaned else "WARNING: no ouput cleaned"
        sys.exit(msg)

    # ------------------------------------------------- start: get the user input
    restart = False
    input_lines = []
    if opts.inputstr:
        # user gave input directly
        input_lines.extend(opts.inputstr.split("\n"))
        pass

    # make sure input file is given and exists
    if len(args) < 1 and not input_lines:
        parser.print_help()
        parser.error("No input given")
        pass

    # check restart files
    rfiles = [x for x in args if os.path.splitext(x)[1] == ".prf"]
    if len(rfiles) > 1:
        parser.error(str(len(rfiles)) + " restart files given, but only one "
                     "restart file can be processed at a time")

    elif len(rfiles) and len(rfiles) != len(args):
        # choose to run a single restart file or input files, but don't mix
        parser.error("Cannot process both restart and input files at same time")

    elif len(rfiles):
        # check to see if the input file exists and get it info
        rfile = rfiles[0]
        if not os.path.isfile(rfile):
            parser.error("Restart file {0} not found".format(rfile))
            pass
        restart = True
        with open(rfile,"rb") as f: the_model = pickle.load(f)
        user_input_dict = {"restart":the_model}

    else:
        # get a list of all input files, order of where to look for file f:
        # 1: f
        # 2: realpath(f)
        # 3: join(Aux/Inputs,f)
        # 4: splitext(f)[0] + .inp
        # 5: join(Aux/Inputs,splitext(f)[0] + .inp)
        foundf, badf = [], []
        for iarg,arg in enumerate(args):
            f = None
            fbase,fext = os.path.splitext(arg)
            if not arg: continue
            if fext == ".prf":
                # one last check for restart files
                parser.error("Cannot process both restart and input "
                             "files at same time")
            elif os.path.isfile(arg):
                f = arg
            elif os.path.isfile(os.path.realpath(arg)):
                f = os.path.realpath(arg)
            elif os.path.isfile(os.path.join(Payette_Inputs,arg)):
                f = os.path.join(Payette_Inputs,arg)
                writeMessage(__file__,"Using " + f + " as input")
            elif not fext or fext == ".":
                # add .inp extension to arg
                arginp = fbase + ".inp"
                if os.path.isfile(arginp):
                    f = arginp
                    writeMessage(__file__,"Using " + f + " as input")
                elif os.path.isfile(os.path.join(Payette_Inputs,arginp)):
                    f = os.path.join(Payette_Inputs,arginp)
                    writeMessage(__file__,"Using " + f + " as input")
                else: pass
                pass

            if not f:
                writeWarning(__file__,"{0} not found in {1}, {2}, or {3}"
                             .format(arg,os.path.dirname(os.path.realpath(arg)),
                                     os.getcwd(),Payette_Inputs))
                badf.append(arg)
                continue

            if f in foundf:
                parser.error("{0} given multiple times".format(arg))
                pass

            foundf.append(f)
            continue

        if badf:
            writeWarning(__file__,"The following files were not found: {0}"
                         .format(", ".join(badf)))
            pass

        if not foundf and not input_lines:
            parser.print_help()
            parser.error("No input files found")
            pass

        # we now have a list of input files, put there contents in to input lines
        for f in foundf:
            input_lines.extend(open(f,"r").readlines())
            continue

        # read the user input
        user_input_dict = readUserInput(input_lines,opts.cchar)
        if not user_input_dict:
            sys.exit("ERROR: user input not found in {0:s}"
                     .format(", ".join(foundf)))
            pass
        pass
    # ------------------------------------------------------- end: get user input

    # number of processors
    nproc = min(min(mp.cpu_count(),opts.nproc),len(user_input_dict))
    opts.verbosity = int(opts.verbosity) if nproc == 1 else 0

    if nproc > 1:
        writeWarning(__file__,
                     "Running with multiple processors.  Logging to the console\n"
                     "         has been turned off.  If a job hangs, [ctrl-c] at the\n"
                     "         console will not shut down Payette.  Instead, put the job\n"
                     "         in the background with [ctrl-z] and then kill it")

    # loop through simulations and run them
    if opts.timing: t0 = time.time()
    if nproc > 1 and len(user_input_dict.keys()) > 1:
        p = mp.Pool(processes=nproc)
        p.map(runJob,user_input_dict.keys())
        p.close()
        p.join()
    else:
        for key in user_input_dict:
            runJob(key)
            continue
        pass
    if opts.timing: printFinalTimingInfo(t0)

    return 0

def runJob(key):

    import Source.Payette_driver as pdrvr
    import Source.Payette_container as pcntnr

    # instantiate Payette object
    if opts.timing: t0 = time.time()

    if restart:
        # @tjf: restart is temporarily disabled
        sys.exit("restart is disabled until fixed")
        the_model = user_input_dict[key]
        the_model.setupRestart()
    else: the_model = pcntnr.Payette(key,user_input_dict[key],opts)

    # run the problem
    if opts.timing: t1 = time.time()
    solve = pdrvr.runProblem(the_model,restart=restart)
    if opts.timing: t2 = time.time()
    if solve == 0:
        reportMessage(__file__,"%s Payette simulation ran to completion"
                      %the_model.name)
    else:
        reportMessage(__file__,"%s Payette simulation failed\n\n"
                      %the_model.name)
        return 1

    # finish up
    the_model.finish()
    del the_model

    # print timing info
    if opts.timing: printTimingInfo(t0,t1,t2,the_model.name)
    return

def printTimingInfo(t0,t1,t2,name=None):
    ttot = time.time() - t0
    texe = t2 - t1
    logmes("\n-------------- %s timing info --------------"%name)
    logmes("total problem execution time:\t%f"%texe)
    logmes("total simulation time:\t\t%f\n"%ttot)
    return None

def printFinalTimingInfo(t0):
    ttot = time.time() - t0
    logmes("\n-------------- simulation timing info --------------")
    logmes("total simulation time:\t\t%f"%ttot)
    return None

def testPayette(argc,argv):
    """
    NAME
       testPayette

    PURPOSE
       walk through and run the Payette test simulations, compare results
       against the accepted results

    AUTHORS
       Tim Fuller, Sandia National Laboratories, tjfulle@sandia.gov
       M. Scot Swan, Sandia National Laboratories, mswan@sandia.gov
    """
    import platform
    import datetime # For the date of when the tests were run
    import getpass  # For finding the username of the person running this
    from Source.Payette_test import findTests
    import Source.Payette_notify

    global testresdir,rantests,topts,term_width,info_width

    # These are used to control formatting for testPayette
    term_width = 80
    info_width = 25

    # *************************************************************************
    # -- command line option parsing
    usage = "usage: testPayette [options]"
    parser = optparse.OptionParser(usage = usage, version = "testPayette 1.0")
    parser.add_option("-k",
                      dest = "KEYWORDS",
                      action = "append",
                      default = [],
                      help = "keywords: [%default]")
    parser.add_option("-K",
                      dest = "NOKEYWORDS",
                      action = "append",
                      default = [],
                      help = "keyword negation: [%default]")
    parser.add_option("-t",
                      dest = "SPECTESTS",
                      action = "append",
                      default = [],
                      help = ("specific tests to run, more than 1 collected: "
                              "[%default]"))
    parser.add_option("-d","--dir",
                      dest="TESTDIR",
                      action="store",
                      default=Payette_Tests,
                      help="Directory to scan for benchmarks [default: %default].")
    parser.add_option("-i","--index",
                      dest="INDEX",
                      action="store_true",
                      default=False,
                      help="Print benchmarks index [default: %default].")
    parser.add_option("-r","--run",
                      dest="RUN",
                      action="store_true",
                      default=False,
                      help="Run benchmarks. [default: %default].")
    parser.add_option("-F",
                      dest="FORCERERUN",
                      action="store_true",
                      default=False,
                      help=("Force benchmarks to be run again if already ran. "
                            "[default: %default]."))
    parser.add_option("-j","--nproc",
                      dest = "nproc",
                      type = int,
                      default = 1,
                      action = "store")
    parser.add_option("-b","--buildpayette",
                      dest="buildpayette",
                      action="store_true",
                      default=False,
                      help=("build payette [default: %default]."))
    parser.add_option("-p","--postprocess",
                      dest = "POSTPROCESS",
                      action = "store_true",
                      default=False,
                      help=("Generate all plots for all tests to be viewed in "
                            "browser"))
    parser.add_option("--notify",
                      dest = "NOTIFY",
                      action = "store_true",
                      default=False,
                      help=("Sends an email with the test results to the "
                            "mailing list."))
    parser.add_option("-I",
                      dest = "IGNOREERROR",
                      action = "store_true",
                      default = False,
                      help=("Ignore noncomforming tests [default: %default]"))
    parser.add_option("-e","--electro",
                      dest = "ELECTROMECH",
                      action = "store_true",
                      default = False,
                      help=("Run electromechanics tests [default: %default]"))

    (topts,args) = parser.parse_args(argv)

    if not os.path.isfile(Payette_Materials_File):
        logerr("buildPayette must be run to generate "
               "Source/Materials/Payette_installed_materials.py")
        sys.exit(130)
        pass

    # number of processors
    nproc = min(mp.cpu_count(),topts.nproc)

    # assume the user wants to run the tests
    if not topts.RUN and not topts.INDEX: topts.RUN = True

    # adjust keywords
    if not topts.ELECTROMECH:
        topts.NOKEYWORDS.append("electromech")
        pass

    logmes(Payette_intro)
    # find tests
    loginf("Testing Payette")
    loginf("Gathering Payette tests from {0}".format(topts.TESTDIR))
    errors, found_tests = findTests(topts.KEYWORDS,topts.NOKEYWORDS,
                                    topts.SPECTESTS,topts.TESTDIR)

    # sort conforming tests from long to fast
    fast_tests = [ val for key,val in found_tests["fast"].items() ]
    medium_tests = [ val for key,val in found_tests["medium"].items() ]
    long_tests = [ val for key,val in found_tests["long"].items() ]
    conforming = long_tests + medium_tests + fast_tests

    # find mathematica notebooks
    mathnbs = {}
    for (dirname,dirs,names) in os.walk(topts.TESTDIR):
        root, base = os.path.split(dirname)
        if base == "nb":
            # a notebook directory has been found, see if there are any
            # conforming tests that use it
            if [x for x in conforming if root in x]:
                mathnbs[root.split(topts.TESTDIR+os.sep)[1]] = [
                    os.path.join(dirname,x) for x in names
                    if x.endswith(".nb") or x.endswith(".m") ]
                pass
            pass
        continue

    if errors and not topts.IGNOREERROR:
        sys.exit("fix nonconforming benchmarks before continuing")
        pass

    loginf("Found {0} Payette tests".format(len(conforming)),end="\n\n")

    if topts.INDEX:
        out = sys.stderr
        out.write("\n\nBENCHMARK INDEX\n\n")
        for speed, tests in found_tests.items():
            for py_mod, py_file in tests.items():
                # load module
                py_path = [os.path.dirname(py_file)]
                fp, pathname, description = imp.find_module(py_mod,py_path)
                py_module = imp.load_module(py_mod,fp,pathname,description)
                fp.close()
                test = py_module.Test()
                out.write(term_width*"="+"\n")
                out.write("Name:  {0}\n".format(test.name))
                out.write("Owner: {0}\n\n".format(test.owner))
                out.write("Description:\n{0}".format(test.description))

                out.write("\nKeywords:\n")
                for kw in test.keywords: out.write("    {0}\n".format(kw))
                continue
            continue
        pass

    if topts.RUN:
        # start the timer
        runtimer = time.time()

        # Make a TestResults directory named "TestResults.{platform}"
        testresdir = os.path.join(os.getcwd(),"TestResults.%s"%platform.system())
        if topts.buildpayette:
            if os.path.isdir(testresdir):
                testresdir0 = "%s_0"%testresdir
                shutil.move(testresdir,testresdir0)
            else: testresdir0 = None
            pass

        if not os.path.isdir(testresdir): os.mkdir(testresdir)

        old_results = {}
        summpy = os.path.join(testresdir,"summary.py")
        summhtml = os.path.splitext(summpy)[0] + ".html"
        if os.path.isfile(summpy):
            try:
                py_path = [os.path.dirname(summpy)]
                py_mod = get_module_name(summpy)
                fp, pathname, description = imp.find_module(py_mod,py_path)
                py_module = imp.load_module(py_mod,fp,pathname,description)
                fp.close()
                try: old_results = py_module.payette_test_results
                except: copyfile(summpy,os.path.join(testresdir,"summary_orig.py"))
                try: os.remove("{0}c".format(summpy))
                except: pass
                pass
            except: pass
            pass

        # check type of old_results, if not dict start over with empty dict
        if not isinstance(old_results,dict):
            old_results = {}

        # Put all run tests in a flattened list for checking if test has been run
        if old_results:
            rantests = [ x for y in old_results.values() for x in y ]
        else:
            rantests = []
            pass

        # reset the test results
        test_statuses = ["pass","diff","fail","notrun","bad input","failed to run"]
        test_res = {}
        for i in test_statuses:
            test_res[i] = {}
            continue


        logmes("="*term_width)
        logmes("Running {0} benchmarks:".format(len(conforming)))
        logmes("="*term_width)

        # run the tests on multiple processors using the multiprocessor map ONLY
        # if nprocs > 1. For debug purposes, when nprocs=1, run without using the
        # multiprocessor map because it makes debugging worse than it should be.
        if nproc == 1:
            all_results = [ runPayetteTest(test) for test in conforming ]

        else:
            p = mp.Pool(processes=nproc)
            all_results = p.map(runPayetteTest,conforming)
            p.close()
            p.join()

        ttot = time.time()-runtimer
        logmes("="*term_width)

        # copy the mathematica notebooks to the output directory
        for mtldir, mathnb in mathnbs.items():
            for item in mathnb:
                fbase = os.path.basename(item)
                fold = os.path.join(testresdir,mtldir,fbase)

                try: os.remove(fold)
                except: pass

                if item.endswith(".m"):
                    # don't copy the .m file, but write it, replacing rundir
                    # and demodir with testresdir
                    with open(fold,"w") as f:
                        for line in open(item,"r").readlines():
                            demodir = os.path.join(testresdir,mtldir) + os.sep
                            rundir = os.path.join(testresdir,mtldir) + os.sep
                            if r"$DEMODIR" in line:
                                line = 'demodir="{0:s}"\n'.format(demodir)
                            elif r"$RUNDIR" in line:
                                line = 'rundir="{0:s}"\n'.format(rundir)
                            else:
                                pass
                            f.write(line)
                            continue
                        pass
                    continue

                else:
                    # copy the notebook files
                    shutil.copyfile(item,fold)
                    pass

                continue

            continue

        # all_results is a large list of the summary of every test. Go through it
        # an use the information to construct the test_res dictionary of the
        # form:
        #    test_res["notrun"] = ...
        #    test_res["pass"] = ...
        #    test_res["diff"] = ...
        #    test_res["failed"] = ...
        for item in all_results:
            for name, summary in item.items():
                status = summary["status"] #@tjf???
                if status not in test_statuses:
                    msg = ("return code {0} from {1} not recognized"
                           .format(status,name))
                    logwrn(msg)
                    continue
                tcompletion = summary["completion time"]
                benchdir = summary["benchmark directory"]
                keywords = summary["keywords"]
                test_res[status][name] = {"benchmark directory":benchdir,
                                          "completion time":tcompletion,
                                          "keywords":keywords}
                continue
            continue

        nnotrun = len(test_res["notrun"])
        nfail = len(test_res["fail"])
        npass = len(test_res["pass"])
        ndiff = len(test_res["diff"])
        nfailtorun = len(test_res["failed to run"])
        txtsummary = ( "SUMMARY\n" +
                 "{0} benchmarks took {1:.2f}s.\n".format(len(conforming),ttot) +
                 "{0} benchmarks passed\n".format(npass) +
                 "{0} benchmarks diffed\n".format(ndiff) +
                 "{0} benchmarks failed\n".format(nfail) +
                 "{0} benchmarks failed to run\n".format(nfailtorun) +
                 "{0} benchmarks not run\n".format(nnotrun) +
                 "For a summary of which benchmarks passed, diffed, failed, " +
                 "or not run, see\n{0}".format(summhtml))

        ######################################################################
        # Make a long summary including the names of what passed and what didn't
        # as well as system information.
        str_date = datetime.datetime.today().strftime("%A, %d. %B %Y %I:%M%p")
        try:
            py_version = "{0}.{1}.{2}".format(sys.version_info.major,
                                              sys.version_info.minor,
                                              sys.version_info.micro)
        except:
            py_version = str(sys.version_info)
            pass

        longtxtsummary = (
             "="*term_width+"\nLONG SUMMARY\n"+
             "{0} benchmarks took {1:.2f}s.\n".format(len(conforming),ttot) +
             "{0:^{1}}\n".format("{0:-^30}".format(" system information "),term_width)+
             "   Date complete:    {0:<}\n".format(str_date)+
             "   Username:         {0:<}\n".format(getpass.getuser())+
             "   Hostname:         {0:<}\n".format(os.uname()[1])+
             "   Platform:         {0:<}\n".format(sys.platform)+
             "   Python Version:   {0:<}\n".format(py_version))

        # List each category (diff, fail, notrun, and pass) and the tests
        test_result_statuses = test_res.keys()
        test_result_statuses.sort()
        for stat in test_result_statuses:
            names = test_res[stat].keys()
            header = "{0:-^30}".format(" "+stat+" ({0}) ".format(len(names)))
            longtxtsummary += "{0:^{1}}\n".format(header,term_width)
            if len(names) == 0:
#                longtxtsummary += "None\n"
                continue
            elif stat == "notrun":
#                longtxtsummary += "None\n"
                continue
            for name in names:
                try:
                    t = "{0:.2f}s.".format(test_res[stat][name]["completion time"])
                except:
                    t = str(test_res[stat][name]["completion time"])
                    pass
                longtxtsummary += "  {0:>8}   {1}\n".format(t,name)
                continue
            continue
        longtxtsummary += "="*term_width + "\n"
        # longtxtsummary is finished at this point
        ######################################################################

        # This sends an email to everyone on the mailing list.
        if topts.NOTIFY:
            logmes("Sending results to mailing list.")
            Payette_notify.notify("Payette Benchmarks",longtxtsummary)
            pass

        logmes(longtxtsummary)
        logmes("="*term_width)
        logmes(txtsummary)
        logmes("="*term_width)

        # write out the results to the summary file
        writePyTestSummary(summpy,test_res)
        writeHTMLTestSummary(summhtml,test_res)

        # cleanup our tracks
        for (dirname,dirs,names) in os.walk(topts.TESTDIR):
            for name in names:
                fbase,fext = os.path.splitext(name)
                delext = [".so",".pyo",".pyc",".log",".out",".prf"]
                if fext in delext: os.remove(os.path.join(dirname,name))
                continue
            continue

        if topts.buildpayette:
            shutil.rmtree(testresdir)
            if testresdir0: shutil.move(testresdir0,testresdir)
            pass
        pass

    return 0

def runPayetteTest(py_file):
    cwd = os.getcwd()
    py_path = [os.path.dirname(py_file)]
    py_mod = get_module_name(py_file)
    fp, pathname, description = imp.find_module(py_mod,py_path)
    py_module = imp.load_module(py_mod,fp,pathname,description)
    fp.close()

    test = py_module.Test()

    # directory where test will be run
    testbase = os.path.dirname(py_file).split(Payette_Tests + os.sep)[1]
    benchdir = os.path.join(testresdir,testbase,test.name)

    # check if benchmark has been run
    ran = [ x for x in rantests if x == test.name ]

    if not topts.FORCERERUN and ran and os.path.isdir(benchdir):
        logmes(  "%s"%(test.name)
                + " "*(50-len(test.name))
                + "{0:>10s}".format("notrun\n")
                + "Test already ran. "
                + "Use -F option to force a rerun")
        result = { test.name:{"status":"notrun",
                              "keywords":test.keywords,
                              "completion time":"NA",
                              "benchmark directory":benchdir } }
        return result

    # Let the user know which test is running
    logmes(  "{0:<{1}}".format(test.name,term_width-info_width)
            + "{0:>{1}s}".format("RUNNING",info_width))

    # Create benchmark directory and copy the input and baseline files into the
    # new directory
    if os.path.isdir(benchdir):
        rmtree(benchdir)
    os.makedirs(benchdir)

    # copy input file, if any
    if test.infile:
        copyfile(test.infile,
                 os.path.join(benchdir,os.path.basename(test.infile)))
        pass

    # copy the python test file and make it executable
    copyfile(py_file,
             os.path.join(benchdir,os.path.basename(py_file)))
    os.chmod(os.path.join(benchdir,os.path.basename(py_file)),0o750)

    if test.baseline:
        if isinstance(test.baseline,list):
            for base_f in test.baseline:
                os.symlink(base_f,os.path.join(benchdir,os.path.basename(base_f)))
                continue
        else:
            os.symlink(test.baseline,
                       os.path.join(benchdir,os.path.basename(test.baseline)))
            pass
        pass

    # move to the new directory and run the test
    os.chdir(benchdir)
    starttime = time.time()

    retcode = test.runTest()

    if topts.POSTPROCESS and os.path.isfile(test.outfile):
        import postprocess as PP
        PP.postprocess(test.outfile,verbosity=0)
        pass

    retcode = ("bad input" if retcode == test.badincode else
               "pass" if retcode ==  test.passcode else
               "diff" if retcode ==  test.diffcode else
               "fail" if retcode ==  test.failcode else
               "failed to run" if retcode == test.failtoruncode else
               "unkown")

    # Print output at completion
    tcompletion = time.time()-starttime
    info_string = "{0} ({1:6.02f}s)".format(retcode.upper(),tcompletion)
    logmes(  "{0:<{1}}".format(test.name,term_width-info_width)
            + "{0:>{1}s}".format(info_string,info_width))

    # return to the directory we came from
    os.chdir(cwd)
    result = { test.name:{"status":retcode,
                          "keywords":test.keywords,
                          "completion time":tcompletion,
                          "benchmark directory":benchdir } }
    return result



def writePyTestSummary(fname,results):
    """ write summary of the results dictionary to python file """
    # the results dictionary is of the form
    # results = { {status: {name: { "benchmark directory":benchdir,
    #                               "completion time":tcompletion,
    #                               "keywords":keywords } } } }
    with open(fname,"w") as f:
        f.write("payette_test_results = {}\n")
        for stat in results:
            # key is one of diff, pass, fail, notrun
            # names are the names of the tests
            f.write("payette_test_results['{0}']=[".format(stat))
            f.write(",".join(["'{0}'".format(x) for x in results[stat].keys()]))
            f.write("]\n")
            continue
        pass
    return

def writeHTMLTestSummary(fname,results):
    """ write summary of the results dictionary to html file """
    # the results dictionary is of the form
    # results = { {status: {name: { "benchmark directory":benchdir,
    #                               "completion time":tcompletion,
    #                               "keywords":keywords } } } }
    resd = os.path.dirname(fname)
    resdb = os.path.basename(resd)
    npass,nfail,ndiff,nskip = [len(results[x]) for x in
                               ["pass","fail","diff","notrun"]]
    with open(fname,"w") as f:
        # write header
        f.write("<html>\n<head>\n<title>Test Results</title>\n</head>\n")
        f.write("<body>\n<h1>Summary</h1>\n")
        f.write("<ul>\n")
        f.write("<li> Directory: %s </li>\n"%resd)
        f.write("<li> Options: %s </li>\n"%(" ".join(sys.argv[1:])))
        f.write("<li> %i pass, %i diff, %i fail, %i notrun </li>\n"
                %(npass,ndiff,nfail,nskip))
        f.write("</ul>\n")

        # write out details test that fail, diff, pass, notrun
        for stat in results.keys():
            f.write("<h1>Tests that showed '%s'</h1>\n<ul>\n"%stat)
            for test in results[stat]:
                tresd = results[stat][test]["benchmark directory"]
                tresdb = results[stat][test]["benchmark directory"]
                f.write("<li>%s  %s</li>\n"%(test,tresdb))
                f.write("<ul>\n")
                f.write("<li>Files: \n")
                files = os.listdir(tresd)
                for ff in files:
                    fpath = os.path.join(tresd,ff)
                    f.write("<a href='%s' type='text/plain'>%s</a> \n"%(fpath,ff))
                    continue
                keywords = "  ".join(results[stat][test]["keywords"])
                try:
                    tcompletion = ("{0:.2f}s."
                                   .format(results[stat][test]["completion time"]))
                except:
                    tcompletion = str(results[stat][test]["completion time"])
                    pass
                status = "Exit {0} {1}".format(stat,tcompletion)
                for myfile in files:
                    if myfile.endswith(".out.html") and topts.POSTPROCESS:
                        tf = os.path.join(tresd,myfile)
                        f.write("<li><a href='{0}'>PostProcessing</a>\n".format(tf))
                f.write("<li>Keywords: %s\n"%(keywords))
                f.write("<li>Status: %s\n"%(status))
                f.write("</ul>\n")
                continue
            f.write("</ul>\n")
            continue
        pass
    return

# spacing used for logs to console
build_sp = "      "

def buildPayette(argc,argv):
    """
    NAME
       buildPayette

    PURPOSE
       create/build: runPayette and testPayette scripts, material library files

    AUTHORS
       Tim Fuller, Sandia National Laboratories, tjfulle@sandia.gov
    """

    # *************************************************************************
    # -- command line option parsing
    usage = ("usage: buildPayette  [options]")
    parser = optparse.OptionParser(usage = usage, version = "buildPayette 1.0")
    parser.add_option("-x","--no-build-libs",
                      dest = "nobuildlibs",
                      action = "store_true",
                      default = False,
                      help = "do not build material libraries: [default: %default]")
    parser.add_option("-m",
                      dest = "mtllib",
                      action = "append",
                      default = [],
                      help = "material libraries to build: [default: %default]")
    parser.add_option("-t","--test",
                      dest = "TEST",
                      action = "store_true",
                      default = False,
                      help = "run testPayette executable: [default: %default]")
    parser.add_option("-o",
                      dest = "OPTIONS",
                      action = "append",
                      default = [],
                      help = ("Options to build (accumulated) [default: %default] "
                              "[choices: [electromech, special]]"))
    parser.add_option("-F",
                      dest = "FORCEREBUILD",
                      action = "store_true",
                      default = False,
                      help = ("Rebuild Payette_materials.py [default:%default]"))

    # the following parser options are shortcuts for building specific materials
    parser.add_option("--dsc", dest = "DSC", action = "store_true", default = False,
                      help = "Build domain_switching_ceramic [default: %default]")
    parser.add_option("--kmm", dest = "KMM", action = "store_true", default = False,
                      help = "Build kayenta [default: %default]")
    parser.add_option("--lpc", dest = "LPC", action = "store_true", default = False,
                      help = "Build pieze_ceramic [default: %default]")
    parser.add_option("--summary",dest="SUMMARY",action="store_true",default=False,
                      help="write summary to screen [default: %default]")

    (opts,args) = parser.parse_args(argv)
    if len(args) > 0:
        parser.print_help()
        parser.error("buildPayette does not require arguments, only options")
        pass

    if opts.SUMMARY:
        write_summary_to_screen()
        sys.exit(0)
        pass

    logmes(Payette_intro)
    # determine if we build all materials, or just a selection
    if opts.DSC: opts.mtllib.append("domain_switching_ceramic")
    if opts.KMM: opts.mtllib.append("kayenta")
    if opts.LPC: opts.mtllib.append("piezo_ceramic")
    buildselect = any(opts.mtllib)
    libstobuild = ["all"] if not buildselect else opts.mtllib

    if opts.FORCEREBUILD:
        try: os.remove(Payette_Materials_File)
        except: pass
        pass

    # clean up options:
    options = []
    for option in opts.OPTIONS:
        if "elec" in option: options.append("electromechanical")
        elif "special" in options: options.append("special")
        else: options.append(option)
        continue

    # intro message
    loginf("Building Payette\n")

    # prepare compiler options
    if Payette_fcompiler:
        f2pyopts = ["--fcompiler={0}".format(Payette_fcompiler)]
    else:
        f2pyopts = ["--f77exec={0}".format(Payette_f77exec),
                    "--f90exec={0}".format(Payette_f90exec)]
        pass

    # compiler options to send to the build scripts
    compiler_info = {"f2py":{"compiler":Payette_f2py,"options":f2pyopts}}

    if not opts.nobuildlibs:

        # get names of materials from Source/Materials
        loginf("finding Payette materials")
        payette_materials = getPayetteMaterials(libstobuild,options)
        loginf("Payette materials found\n")

        # build the requested material libraries
        errors, payette_materials = buildPayetteMaterials(payette_materials,
                                                          compiler_info)
        # material libraries built, now write the
        # Source/Materials/Payette_Materials file containing all materials
        writePayetteMaterials(payette_materials)

    else:
        errors = 0
        pass

    # if the user wanted only to build certain libraries, return when built
    if opts.mtllib: return errors

    # check that runPayette works
    test_error = testRunPayette(opts.TEST)

    if errors and test_error == 0:
        # testRunPayette completed without error, but there were previous build
        # errors, meaning that some libraries did not build, but Payette still
        # built.
        errors = 55
    elif not errors and test_error != 0:
        # testRunPayette completed with error, but everything built fine,
        # something is wrong...
        errors = 75
    else: pass

    errors += test_error

    return errors

def testRunPayette(test):
    """
    NAME
       testRunPayette

    PURPOSE
       test that runPayette executes properly for [-h]
       test that testPayette executes properly for [-k elastic -K kayenta]

    AUTHORS
       Tim Fuller, Sandia National Laboratories, tjfulle@sandia.gov
    """

    begmes("INFO: testing that runPayette [-h] executes normally",pre="")
    cmd = [Payette_runPayette,"-h"]
    runcheck = sbp.Popen(cmd,stdout=sbp.PIPE,stderr=sbp.STDOUT)
    runcheck.wait()
    if runcheck.returncode != 0:
        sbp_msg = runcheck.communicate()[0]
        if type(sbp_msg) == bytes:
            sbp_msg = sbp_msg.decode("ascii")
        msg = [x for x in sbp_msg.split("\n") if x]
        message = ("the following error was trapped from runPayette [-h]:\n"
                   "%s"%("="*25+" Start Error\n"+sbp_msg+"\n"+"="*25+" End Error\n"))
        buildfail(message)

        logmes("<<< IF >>> no other build errors were encountered, "
               "please let the Payette developers know so a fix can be found")
        return 1
    else:
        endmes("runPayette [-h] executed normally\n")
        pass

    if not test: return 0

    begmes("INFO: testing that testPayette [-k elastic -K kayenta] "
             "executes normally")
    cmd = [os.path.join(tools_d,"testPayette"),"-k","elastic","-K","kayenta","-F",
           "buildPayette"]
    runcheck = sbp.Popen(cmd,stdout=sbp.PIPE,stderr=sbp.STDOUT)
    runcheck.wait()
    if runcheck.returncode != 0:
        sbp_msg = runcheck.communicate()[0]
        if type(sbp_msg) == bytes:
            sbp_msg = sbp_msg.decode("ascii")
        msg = [x for x in sbp_msg.split("\n") if x]
        message = ("the following error was trapped from "
                   "testPayette [-k elastic -K kayenta]:\n%s"%(msg[-1]))
        buildfail(message)
        message = ("please let the Payette developers know so a fix can be found\n"
                   "removing {runPayette,testPayette} and exiting")
        logmes(message)
        return 1
    else:
        endmes("testPayette [-k elastic -K kayenta] executed normally\n")
        pass
    return 0

def writePayetteMaterials(payette_materials):
    """
        Write the Source/Materials/Payette_materials.py file containing a
        dictionary of installed models and model attributes
    """

    loginf("writing {0}"
           .format("$PAYETTE_ROOT" + Payette_Materials_File.split(Payette_Root)[1]))

    try: lines = open(Payette_Materials_File,"r").readlines()
    except: lines = []

    # get list of previously installed materials
    installed_materials = []
    for line in lines:
        if "Payette_Installed_Materials" in line:
            installed_materials = eval(line.strip().split("=")[1])
            break
        continue

    # remove failed materials from installed materials
    for material in [ x for x in payette_materials
                      if payette_materials[x]["build requested"]
                      and payette_materials[x]["build failed"] ]:
        try: installed_materials.remove(material)
        except: pass
        continue

    # add built materials to installed materials
    for material in [ x for x in payette_materials
                      if payette_materials[x]["build requested"]
                      and payette_materials[x]["build succeeded"] ]:
        if material not in installed_materials:
            installed_materials.append(material)
            pass
        continue

    # check that all installed materials are in all_materials
    all_materials = [payette_materials[x]["name"] for x in payette_materials]
    for material in installed_materials:
        if material not in all_materials:
            logwrn("installed material {0} not in payette_materials"
                   .format(material))
            pass
        continue
    installed_materials = [ x for x in installed_materials if x in all_materials]

    # write the Payette_Materials_File file
    with open(Payette_Materials_File,"w") as f:
        intro = (
"""# ****************************************************************************** #
#                                                                                #
# This file was generated automatically by the Payette. It contains important    #
# directives for materials detected and built by Payette.                        #
#                                                                                #
# This file is intended to be imported by Payette so that material classes can   #
# be instantiated from built materials.                                          #
#                                                                                #
# DO NOT EDIT THIS FILE. This entire file is regenerated automatically each time #
# Payette is built. Any changes you make to this file will be overwritten.       #
#                                                                                #
# If changes are needed, please contact the Payette developers so that changes   #
# can be made to the build scripts.                                              #
# ****************************************************************************** #
""")
        f.write(intro)
        begmes("writing successfully installed materials",pre=build_sp)
        f.write("Payette_Installed_Materials={0}\n".format(installed_materials))
        endmes("successfully installed materials written")

        f.write("Payette_Constitutive_Models={}\n")

        begmes("writing constitutive model declarations",pre=build_sp)
        for material in installed_materials:
            payette_material = payette_materials[material]
            py_module = payette_material["module"]
            name = payette_material["name"]
            aliases = payette_material["aliases"]
            class_name = payette_material["class name"]
            py_path = "Source.Materials." + py_module
            f.write("from {0} import {1}\n".format(py_path, class_name))
            f.write('Payette_Constitutive_Models["{0}"]='
                    '{{"class name":{1},'
                    '"aliases":{2}}}\n'.format(name,class_name,aliases))
            continue
        pass
        endmes("constitutive model declarations written")

    loginf("{0} written\n"
           .format("$PAYETTE_ROOT" + Payette_Materials_File.split(Payette_Root)[1]))
    return

def buildPayetteMaterials(payette_materials,compiler_info):
    """
    NAME
       buildPayetteMaterials

    PURPOSE
       build the library files for each material.  most materials are
       are implemented as fortran files and need to be compiled with
       f2py.

    AUTHORS
       Tim Fuller, Sandia National Laboratories, tjfulle@sandia.gov
    """

    loginf("building Payette material libraries")

    # now build the materials
    errors = 0

    requested_builds = [ x for x in payette_materials
                         if payette_materials[x]["build requested"]]
    if not requested_builds: logmes("no material libraries to build",pre=build_sp)

    for material in requested_builds:

        # get attributes
        name = payette_materials[material]["name"]
        libname = payette_materials[material]["libname"]
        build_script = payette_materials[material]["build script"]
        parse_error = payette_materials[material]["parse error"]
        begmes("building %s" % (libname),pre=build_sp)

        if parse_error:
            payette_materials[material]["build failed"] = True
            endmes("{0} skipped due to previous errors".format(libname))
            continue

        if not build_script:
            payette_materials[material]["build succeeded"] = True
            endmes("{0} built ".format(libname))
            continue

        # import build script
        py_mod, py_path = get_module_name_and_path(build_script)
        fp, pathname, description = imp.find_module(py_mod,py_path)
        build = imp.load_module(py_mod,fp,pathname,description)
        fp.close()

        try:
            build = build.Build(name,libname,compiler_info)
            build_error = build.build_extension_module()

#        except AttributeError:
#            build_error = 66

        except BuildError as error:
            build_error = error.errno
            pass

        except Exception as error:
            build_error = error.errno
            if build_error not in [1,2,5,10,35,40,66]:
                # raise what ever error came through
                raise
            else:
                if hasattr(error,"message"):
                    logwrn(error.message,pre=build_sp)
                else: raise
                pass
            pass

        if build_error:
            errors += 1
            payette_materials[material]["build failed"] = True
            if build_error == 5 or build_error == 10 or build_error == 40:
                pass
            elif build_error == 66:
                logwrn("{0}: missing attribute: build".format(build_script))
            else:
                msg = ("failed to build {0} extension module. see {1}"
                       .format(libname,"build.echo"))
                logwrn(msg,pre="\t\t")
                pass
        else:
            endmes("%s built " % (libname))
            payette_materials[material]["build succeeded"] = True
            pass

        # remove bite compiled files
        try: os.remove(build_script + "c")
        except: pass

        continue

    loginf("Payette material libraries built\n")
    failed_materials = [payette_materials[x]["libname"] for x in payette_materials
                        if payette_materials[x]["build requested"]
                        and payette_materials[x]["build failed"]]
    built_materials = [payette_materials[x]["libname"] for x in payette_materials
                       if payette_materials[x]["build requested"]
                       and payette_materials[x]["build succeeded"]]

    if failed_materials:
        errors = 55
        logwrn("The following material libraries WERE NOT built: {0}\n"
               .format(", ".join(failed_materials)))
        pass

    if built_materials:
        loginf("The following material libraries WERE built: {0}\n"
               .format(", ".join(built_materials)))
        pass

    # remove cruft
    for f in [x for x in os.listdir(Payette_Toolset)
              if x.split(".")[-1] in ["so","o"]]:
        os.remove(f)
        continue

    return errors, payette_materials

def getPayetteMaterials(requested_libs=["all"],options=[]):

    """
        Read python files in Source/Materials and determine which are interface
        files for material models.  If they are, add them to the payette_materials
        dictionary, along with their attributes
    """

    import pyclbr

    buildselect = False if requested_libs[0] == "all" else True

    def get_super_classes(name, data):
        super_class_names = []
        for super_class in data.super:
            if super_class == "object":
                continue
            if isinstance(super_class, basestring):
                super_class_names.append(super_class)
            else:
                super_class_names.append(super_class.name)
                pass
            continue
        return super_class_names

    payette_materials, material_depends = {}, {}
    py_files = [os.path.join(Payette_Materials,x)
                for x in os.listdir(Payette_Materials) if x.endswith(".py")]

    # go through list of python files in
    for py_file in py_files:
        verb = "qsfail" in py_file

        parse_error = False

        py_mod, py_path = get_module_name_and_path(py_file)
        fp, pathname, description = imp.find_module(py_mod,py_path)
        py_module = imp.load_module(py_mod,fp,pathname,description)
        fp.close()

        attributes = getattr(py_module,"attributes",None)
        if not attributes: continue

        # check if this is a payette material
        try: payette_material = attributes["payette material"]
        except: continue
        if not payette_material: continue

        # check if a constitutive model class is defined
        class_data = pyclbr.readmodule(py_mod,path=[os.path.dirname(py_file)])

        try: proto = class_data["Parent"].name
        except: proto = "ConstitutiveModelPrototype"

        for name, data in class_data.items():
            class_name = data.name
            constitutive_model = proto in get_super_classes(name,data)
            if constitutive_model: break
            continue

        if not constitutive_model:
            del py_module
            continue

        # file is an interface file check attributes, define defaults
        try: name = attributes["name"]
        except: logerr("No name attribute given in {0}".format(py_file))
        name = name.replace(" ","_").lower()

        try: libname = attributes["libname"]
        except: libname = name + Payette_Extension_Module_Fext

        # material type
        try: material_type = attributes["material type"]
        except: logerr("No material type attribute given in {0}".format(py_file))
        electromtl = bool([x for x in material_type if "electro" in x])
        specialmtl = bool([x for x in material_type if "special" in x])

        # get aliases, they need to be a list of aliases
        try: aliases = attributes["aliases"]
        except: aliases = []
        if isinstance(aliases,str): aliases = [aliases]
        aliases = [ x.replace(" ","_").lower() for x in aliases]

        # fortran model set up
        try: fortran_source = attributes["fortran source"]
        except: fortran_source = False
        try: build_script = attributes["build script"]
        except: build_script = None
        try: depends = attributes["depends"]
        except: depends = None

        # all fortran models must give a build script
        if fortran_source and not build_script:
            parse_error = True
            logerr("No build script given for fortran source in {0} for {1}"
                   .format(py_file,libname),pre=build_sp)

        # unless it is not needed...
        elif build_script == "Not_Needed":
            build_script = None

        # and the build script must exist.
        elif build_script != None:
            if not os.path.isfile(build_script):
                parse_error = True
                logerr("build script {0} not found".format(build_script))
                pass
            pass

        # collect all parts
        mtl_dict = {
            "name":name,
            "libname":libname,
            "fortran source":fortran_source,
            "build script":build_script,
            "aliases":aliases,
            "material type":material_type,
            "module":py_mod,
            "file":py_file,
            "class name":class_name,
            "depends":depends,
            "parse error":parse_error,
            "build requested":False, # by default, do not build the material
            "build succeeded":False,
            "build failed":False
            }

        payette_materials[name] = mtl_dict
        # payette_materials[py_mod] = mtl_dict
        del py_module

        # if building select libraries, check if this is it
        if buildselect and name not in requested_libs: continue

        elif not buildselect:
            # only build electromechanical models if requested
            if electromtl and "electromechanical" not in options: continue
            elif specialmtl and "special" not in options: continue
            else: pass

        else: pass

        # by this point, we have filtered out the materials we do not want to
        # build, so request that it be built
        payette_materials[name]["build requested"] = True

        continue

    dependent_materials = [ x for x in payette_materials
                            if payette_materials[x]["depends"] ]
    if dependent_materials:
        for material in dependent_materials:
            depends_on = payette_materials[material]["depends"]
            # user has requested to build a material that depends on another.
            # make sure that the other material exists
            if depends_on not in payette_materials:
                raise BuildError("{0} depends on {1} which was not found"
                                 .format(material,depends_on),25)

            # if material was requested to be built, make sure the material it
            # depends on is also built
            if payette_materials[material]["build requested"]:
                payette_materials[depends_on]["build requested"] = True
                pass

            continue
        pass

    if buildselect:
        # the user may have requested to build a material that does not exist,
        # let them know
        all_names = [payette_materials[x]["name"] for x in payette_materials]
        non_existent = []
        for name in requested_libs:
            if name not in all_names: non_existent.append(name)
            continue
        if non_existent:
            logwrn("requested material[s] {0} not found"
                   .format(", ".join(non_existent)),pre=build_sp)
            pass
        pass

    return payette_materials

def buildfail(msg):
    msg = msg.split("\n")
    err = "BUILD FAILED"
    s = r"*"*int((80 - len(err))/2)
    logmes("\n\n%s %s %s\n"%(s,err,s))
    for line in msg: logmes("BUILD FAIL: %s"%(line))
    logmes("\n\n")
    return

def write_summary_to_screen():
    from os.path import dirname,realpath,join,splitext,islink
    def no_code_lines(fpath):
        nlines = 0
        if splitext(fpath)[1] not in Payette_Code_Exts: return nlines
        for line in open(fpath,"r").readlines():
            line = line.strip().split()
            if not line or line[0] == "#": continue
            nlines += 1
            continue
        return nlines

    rootd = dirname(dirname(realpath(__file__)))
    Payette_Dirs,Payette_Files = [], []
    Payette_Code_Exts = [".py",".pyf","",".F",".C",".f"]
    Payette_Exts = Payette_Code_Exts + [".inp",".tex",".pdf"]
    for dirnam,dirs,files in os.walk(rootd):
        if ".svn" in dirnam: continue
        Payette_Dirs.extend([join(dirnam,d) for d in dirs])
        Payette_Files.extend([join(dirnam,f) for f in files
                              if not islink(join(dirnam,f))
                              and splitext(f)[1] in Payette_Exts])
        continue
    No_Payette_Lines = sum([no_code_lines(f) for f in Payette_Files])
    No_Payette_Dirs = len(Payette_Dirs)
    No_Payette_Files = len(Payette_Files)
    No_Payette_Inp_Files = len([x for x in Payette_Files if x.endswith(".inp")])
    No_Payette_Py_Files = len([x for x in Payette_Files
                              if x.endswith(".py") or x.endswith(".pyf")])
    logmes(Payette_intro)
    logmes("Summary of Project:")
    logmes("\tNumber of files in project:         {0:d}".format(No_Payette_Files))
    logmes("\tNumber of directories in project:   {0:d}".format(No_Payette_Dirs))
    logmes("\tNumber of input files in project:   {0:d}"
           .format(No_Payette_Inp_Files))
    logmes("\tNumber of python files in project:  {0:d}".format(No_Payette_Py_Files))
    logmes("\tNumber of lines of code in project: {0:d}".format(No_Payette_Lines))
    return

def Payette(args):
    """
    NAME
       Payette

    PURPOSE
       Main function that calls either runPayette or testPayette

    AUTHORS
       Tim Fuller, Sandia National Laboratories, tjfulle@sandia.gov
    """
    payette = None
    if "--profile" in args:
        profile = True
        args.remove("--profile")
        import cProfile
    else: profile = False

    if args and args[1] == "test":
        args.remove("test")
        if profile:
            cmd = "testPayette(len(args[1:]),args[1:])"
            f = "payette.prof"
            cProfile.runctx(cmd,globals(),locals(),f)
            payette = 0
        else: payette = testPayette(len(args[1:]),args[1:])

    elif args and args[1] == "run":
        args.remove("run")
        if profile:
            cmd = "runPayette(len(args[1:]),args[1:])"
            f = "payette.prof"
            cProfile.runctx(cmd,globals(),locals(),f)
            payette = 0
        else: payette = runPayette(len(args[1:]),args[1:])

    elif args and args[1] == "build":
        args.remove("build")
        build_Payette = buildPayette(len(sys.argv[1:]),sys.argv[1:])

        error, warn = 0, 0
        if build_Payette == 0:
            loginf("buildPayette succeeded\n")

        elif build_Payette == 55:
            warn += 1
            logwrn("buildPayette failed to build one or more material libraries\n")

        elif build_Payette == 75:
            error += 1
            logerr("buildPayette failed due to an unknown error\n")

        else:
            logerr("buildPayette failed\n")
            error += 1
            pass

        if error: payette_built(False)
        else: payette_built(True)

        if not error and not warn: logmes("Enjoy Payette!")
        elif warn: logmes("You've been warned, tread lightly!")
        else: logmes("Better luck next time!")

        return build_Payette

    else:
        logerr("first argument to Payette must be either run, build, or test")
        print_help()
        return 1
        pass

    return payette

def payette_built(built):
    """ write to the global config file that Payette built """
    built = bool(built)
    lines = open(Payette_config_file).readlines()
    with open(Payette_config_file,"w") as f:
        for line in lines:
            if line.split() and line.strip().split()[0] == "Payette_built":
                line = "Payette_built = {0}\n".format(bool(built))
                pass
            f.write(line)
            continue
        pass
    return


def get_module_name(py_file):
    return os.path.splitext(os.path.basename(py_file))[0]

def print_help():
    logmes("""
NAME
   Payette

PURPOSE
   Payette is a object oriented single element material model driver written in
   python.

USAGE
   Payette <test,run> [options] <filename>
""")
    return

if __name__ == "__main__":

    # Make sure we run this script under python 2.6
    checkPythonVersion()
    payette = Payette(sys.argv)
    sys.exit(payette)


