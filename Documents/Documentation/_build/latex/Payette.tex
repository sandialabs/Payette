% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{Payette Documentation}
\date{April 11, 2012}
\release{1.0}
\author{Tim Fuller, Scot Swan}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{Files/introduction:introduction}\label{Files/introduction::doc}\label{Files/introduction:payette-material-model-driver-official-documentation}
\href{http://www.eng.utah.edu/~timothyf}{Payette} is an object oriented
material model driver written in \href{http://www.python.org}{Python} designed
for rapid development and testing of material models. The core of the
\emph{Payette} code base is written in Python, with the exception of many material
models and optimization routines that are written in Fortran and wrapped by
\href{http://www.scipy.org/F2py}{*f2py*}.

\emph{Payette} is free software released under the
\href{http://www.wikipedia.org/wiki/MIT\_License}{MIT License}


\section{Why a Single Element Driver?}
\label{Files/introduction:why-a-single-element-driver}
Due to their complexity, it is often over kill to use a finite element code for
constitutive model development. In addition, features such as artificial
viscosity can mask the actual material response from constitutive model
development. Single element drivers allow the constituive model developer to
concentrate on model development and not the finite element response. Other
advantages of the \emph{Payette} (or, more generally, of any stand-alone constitutive
model driver) are
\begin{itemize}
\item {} 
\emph{Payette} is a very small, special purpose, code. Thus, maintaining and
adding new features to \emph{Payette} is very easy.

\item {} 
Simulations are not affected by irrelevant artifacts such as artificial
viscosity or uncertainty in the handling of boundary conditions.

\item {} 
It is straightforward to produce supplemental output for deep analysis of the
results that would otherwise constitute an unnecessary overhead in a finite
element code.

\item {} 
Specific material benchmarks may be developed and automatically run quickly
any time the model is changed.

\item {} 
Specific features of a material model may be exercised easily by the model
developer by prescribing strains, strain rates, stresses, stress rates, and
deformation gradients as functions of time.

\end{itemize}


\section{Why Python?}
\label{Files/introduction:why-python}
Python is an interpreted, high level object oriented language. It allows for
writing programs rapidly and, because it is an interpreted language, does not
require a compiling step. While this might make programs written in python slower
than those written in a compiled language, modern packages and computers make the
speed up difference between python and a compiled language for single element
problems almost insignificant.

For numeric computations, the \href{http://www.numpy.org}{NumPy} and \href{http://www.scipy.org}{SciPy} modules allow programs written in Python to leverage
a large set of numerical routines provided by \code{LAPACK}, \code{BLASPACK},
\code{EIGPACK}, etc. Python's APIs also allow for calling subroutines written in
C or Fortran (in addition to a number of other languages), a prerequisite for
model development as most legacy material models are written in Fortran. In
fact, most modern material models are still written in Fortran to this day.

Python's object oriented nature allows for rapid installation of new material
models.


\section{Historical Background}
\label{Files/introduction:historical-background}
\emph{Payette} is an outgrowth of Tom Pucick's \emph{MMD} and \href{http://www.mech.utah.edu/~brannon/}{Rebecca Brannon's} \emph{MED} drivers. Both these other drivers
are written in Fortran.


\section{Simulation Approach}
\label{Files/introduction:simulation-approach}
\emph{Payette} exercises a material model directly by ``driving'' it through user
specified mechanical and electrical inputs.


\subsection{Supported Drivers}
\label{Files/introduction:supported-drivers}

\subsubsection{Mechanical}
\label{Files/introduction:mechanical}
\textbf{Direct}
\begin{itemize}
\item {} 
Strain rate

\item {} 
Strain

\item {} 
Deformation gradient

\item {} 
Velocity

\item {} 
Displacement

\end{itemize}

\textbf{Inverse}
\begin{itemize}
\item {} 
Stress

\item {} 
Stress rate

\end{itemize}


\subsubsection{Electrical}
\label{Files/introduction:electrical}
\textbf{Direct}
\begin{itemize}
\item {} 
Electric field

\end{itemize}


\chapter{Developer Guide}
\label{Files/layout::doc}\label{Files/layout:developer-guide}

\section{\emph{Payette} Directory Structure}
\label{Files/layout:payette-directory-structure}
The \code{Payette} project has the following directory structure

\begin{Verbatim}[commandchars=\\\{\}]
PAYETTE\_ROOT
  configure.py
  \_\_init\_\_.py
  README

  Aux/
    Inputs/

  MaterialsDatabase/

  Documents/
    Documentation/
    Presentations/

  Examples/

  Source/
    Fortran/
    Materials/
      Fortran/
      Library/

  Tests/
    Materials/
    Regression/

  Toolset/
\end{Verbatim}


\section{Coding Style Guide}
\label{Files/layout:coding-style-guide}
All new code in \emph{Payette} should adhere sctrictly to the style described in
Python's \href{http://www.python.org/dev/peps/pep-0008/}{PEP-0008} and docstrings
should follow NumPy's \href{https://github.com/numpy/numpy/blob/master/doc/HOWTO\_DOCUMENT.rst.txt}{docstring guide}. One
exception to the Python style guide is the naming convention of files in
\emph{Payette}: all file names begin with \code{Payette\_}.

It is highly recommended to use tools such as \emph{pylint} and \emph{pep8} to perform
code analysis on all new and existing code.

\begin{notice}{note}{Note:}
Many of the original files in \emph{Payette} were not written to the
Python style guide. As time allows, these files are being modified to
adhere to the standards.
\end{notice}


\chapter{Obtaining \emph{Payette}}
\label{Files/obtaining:obtaining-payette}\label{Files/obtaining::doc}
\emph{Payette} is an open source project licensed under the MIT license. A copy of
the source code may be obtained by contacting \href{mailto:tjfulle@sandia.gov}{Tim Fuller}.

For students in the \href{http://www.coe.utah.edu}{School of Engineering} at the
University of Utah, a copy of \emph{Payette} may by obtained by:

\begin{Verbatim}[commandchars=\\\{\}]
git clone cade\PYGZus{}lab\PYGZus{}user\PYGZus{}name@lenny.eng.utah.edu:/csm/local/git/Payette.git Payette
\end{Verbatim}


\chapter{Building \emph{Payette}}
\label{Files/building:building-payette}\label{Files/building::doc}
\emph{Payette} is an object oriented material driver. The majority of the source code
is written in Python and requires no additional building. Many of the material
models, however, are written in Fortran and require a seperate compile step.


\section{System Requirements}
\label{Files/building:system-requirements}
\emph{Payette} has been built and tested extensively on several versions of linux and
the Apple Mac OSX 10.6 operating systems. It is unknown whether or not \emph{Payette}
will run on Windows.


\section{Required Software}
\label{Files/building:required-software}
\emph{Payette} requires the following software installed for your platform:
\begin{enumerate}
\item {} 
\href{http://www.python.org/}{Python 2.6} or newer

\item {} 
\href{http://www.numpy.org/}{NumPy 1.5} or newer

\item {} 
\href{http://www.scipy.org/}{SciPy 0.1} or newer

\end{enumerate}

The required software may be obtained in one of several ways:
\begin{itemize}
\item {} 
\emph{Install from your systems package manager}

\code{apt-get} on Ubuntu, \code{yum} on Fedora, \code{rpm} on Red Hat, etc. On the
Mac, we have had great success using software installed by \href{http://www.macports.org}{MacPorts}.

\begin{notice}{warning}{Warning:}
We have had varying degrees of success using software installed by
package managers on various linux distributions and have had to resort
to building from source or using Sage, as described below.
\end{notice}

\item {} 
\emph{Build each from source}

An involved, but fairly straight forward process.

\item {} 
\emph{Use Python, NumPy, and SciPy installed with}
\href{http://www.sagemath.org/}{Sage 4.7} \emph{or newer}

This option is perhaps the easiest, since Sage provides prebuilt binaries
for the Mac and many linux platforms. Their build process has also proven
to be very robust on many platforms.

\begin{notice}{note}{Note:}\begin{itemize}
\item {} 
Some features are disabled when using Sage. In particular, callback
functions from Fortran subroutines to Python functions.

\item {} 
Using Sage is not as extensively tested as using a seperate Python
installation.

\end{itemize}
\end{notice}

\end{itemize}


\section{Installation}
\label{Files/building:installation}\begin{enumerate}
\item {} 
Make sure that all \emph{Payette} prerequisites are installed and working properly.

\item {} 
Add \code{PAYETTE\_ROOT} to your \code{PYTHONPATH} environment variable

\item {} 
Add \code{PAYETTE\_ROOT/Toolset} to your \code{PATH} environment variable

\item {} 
Change to \code{PAYETTE\_ROOT} and run:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} PYTHON configure.py
\end{Verbatim}

where \code{PYTHON} is the python interpreter that has \emph{NumPy} and \emph{SciPy}
installed. If using Sage, replace \code{PYTHON} with \code{sage -python}.

\code{configure.py} will write the \emph{Payette} configuration file and the
following executable scripts:

\begin{Verbatim}[commandchars=\\\{\}]
PAYETTE\PYGZus{}ROOT
  Payette\PYGZus{}config.py
  Toolset/
    buildPayette
    cleanPayette
    runPayette
    testPayette
\end{Verbatim}

\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
execute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} buildPayette
\end{Verbatim}

which will build the \emph{Payette} material libraries and create a configuration
file of all built and installed materials in
\code{PAYETTE\_ROOT/Source/Materials/Payette\_installed\_materials.py}

\end{enumerate}


\section{Testing the Installation}
\label{Files/building:testing-the-installation}
To test \emph{Payette} after installation, execute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} testPayette -k regression -k fast
\end{Verbatim}

which will run the ``fast'' ``regression'' tests. To run the full test suite execute:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} testPayette -j4
\end{Verbatim}

Please note that running all of the tests takes several minutes.


\section{Known Issues}
\label{Files/building:known-issues}\begin{enumerate}
\item {} 
\emph{callbacks}

A callback function is a Python function accessible by Fortran subroutines
through a callback mechanism provided by \emph{f2py}. The \emph{NumPy} and \emph{SciPy}
packages distributed by many of the different linux distributions package
managers have broken dependencies. In particular, callback functions seem to
be broken on many linux systems. The easy work around is to configure
\emph{Payette} with \code{-{-}no-callback}. Another work around is passing different
fortran compilers to configure.py (\code{-{-}f77exec=} , \code{-{-}f90exec=}) and seeing
if that makes a difference.

\item {} 
\emph{segfault}

A segfault error is usually a result of a broken callback.  See 0) above.

\item {} 
\emph{Unable to build}

Difficulty building \emph{Payette} is usually the result of broken \emph{NumPy} and
\emph{SciPy} installations and the workaround involves reinstalling all software
packages from sourc. If you are uncomfortable installing these software
packages from source, consider using Sage to build and run \emph{Payette}.

\end{enumerate}


\section{Troubleshooting}
\label{Files/building:troubleshooting}
If you experience problems when building/installing/testing \emph{Payette}, you can
ask help from \href{mailto:tjfulle@sandia.gov}{Tim Fuller} or \href{mailto:mswan@sandia.gov}{Scot Swan}. Please include the following information in your message:
\begin{enumerate}
\item {} 
Are you using Sage, or not

\item {} 
Platform information OS, its distribution name and version information etc.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} PYTHON -c 'import os,sys;print os.name,sys.platform'
\PYGZpc{} uname -a
\end{Verbatim}

\item {} 
Information about C,C++,Fortran compilers/linkers as reported by
the compilers when requesting their version information, e.g.,
the output of:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} gcc -v
\PYGZpc{} gfortran --version
\end{Verbatim}

\item {} 
Python version:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} PYTHON -c 'import sys;print sys.version'
\end{Verbatim}

\item {} 
\emph{NumPy} version:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} PYTHON -c 'import numpy;print numpy.\PYGZus{}\PYGZus{}version\PYGZus{}\PYGZus{}'
\end{Verbatim}

\item {} 
\emph{SciPy} version:

\begin{Verbatim}[commandchars=\\\{\}]
\PYGZpc{} PYTHON -c 'import scipy;print scipy.\PYGZus{}\PYGZus{}version\PYGZus{}\PYGZus{}'
\end{Verbatim}

\item {} 
The contents of the \code{PAYETTE\_ROOT/Payette\_config.py} file

\item {} 
Feel free to add any other relevant information.

\end{enumerate}


\chapter{Running \emph{Payette}}
\label{Files/running_payette::doc}\label{Files/running_payette:running-payette}

\section{Getting Started}
\label{Files/running_payette:getting-started}
Interacting with \emph{Payette} is done through the \code{runPayette} script and
properly formatted input files. The basic usage of \code{runPayette} is:

\begin{Verbatim}[commandchars=\\\{\}]
\% runPayette input\_file
\end{Verbatim}

For a complete list of options for \code{runPayette} execute:

\begin{Verbatim}[commandchars=\\\{\}]
\% runPayette -h
\end{Verbatim}


\section{Simulation Output}
\label{Files/running_payette:simulation-output}
For a simulation titled \code{simnam}, the following output is created by
\code{runPayette}:

\begin{Verbatim}[commandchars=\\\{\}]
simnam.log      (ascii log file)
simnam.out      (ascii space delimited output file)
simnam.math1    (ascii Mathematica auxiliary postprocessing file)
simnam.math2    (ascii Mathematica auxiliary postprocessing file)
simnam.prf      (binary restart file)
simnam.props    (ascii list of checked material parameters)
\end{Verbatim}


\chapter{\emph{Payette} Input File Formatting}
\label{Files/input_file_formatting::doc}\label{Files/input_file_formatting:payette-input-file-formatting}

\section{Input File Blocks}
\label{Files/input_file_formatting:input-file-blocks}\label{Files/input_file_formatting:id1}
Input files are comprised of several ``blocks'' of instruction for
\code{runPayette}. A block is a group of instructions contained in a \code{begin
\textless{}block\textgreater{} {[}block name{]} ... end \textless{}block\textgreater{}} pair:

\begin{Verbatim}[commandchars=\\\{\}]
begin \textless{}block\textgreater{} [block name]
        .
        .
        .
end \textless{}block\textgreater{}
\end{Verbatim}

\begin{notice}{note}{Note:}
The case of the text in the input file does not matter, nor does the
indentation on each line. Indentation of input blocks is used only for clarity
in this document. \code{runPayette} supports \code{\#} and \code{\$} as native
comment characters and the user can pass the optional \code{-{-}cchar=userchar} to
specify any character \code{userchar} to be used as a comment character.
\end{notice}


\section{Required Blocks}
\label{Files/input_file_formatting:required-blocks}\label{Files/input_file_formatting:id2}
The blocks required by \code{runPayette} are:

\begin{Verbatim}[commandchars=\\\{\}]
begin simulation \textless{}title\textgreater{}

  begin material

    [material options]

  end material

  begin boundary

    [boundary options]

  end boundary

end simulation
\end{Verbatim}

The ordering of the blocks within the \code{simulation} block does not matter.
However, all blocks for a given simulation must be nested in the \code{simulation}
block. Details of the required content of each block follows.


\subsection{The \texttt{simulation} Block}
\label{Files/input_file_formatting:simulation-block}\label{Files/input_file_formatting:the-simulation-block}
Each input file must have a \code{simulation} block with title for that simulation. The
title of the simulation will serve as the basename for all simulation output,
with spaces replaced with underscores.

\begin{notice}{note}{Note:}
\code{runPayette} supports an arbitrary number of \code{simulation} blocks in a
single input file.
\end{notice}


\subsection{The \texttt{material} Block}
\label{Files/input_file_formatting:material-block}\label{Files/input_file_formatting:the-material-block}
In the \code{material} block, the constitutive model and material parameters are
defined. A \code{material} block takes the following form:

\begin{Verbatim}[commandchars=\\\{\}]
begin material
  constitutive model \textless{}model\textgreater{}
  parameter 1 \textless{}value\textgreater{}
  parameter 2 \textless{}value\textgreater{}
  parameter n \textless{}value\textgreater{}
end material
\end{Verbatim}

\begin{notice}{note}{Note:}
Parameters are associated with the material, and not the constitutive model.
This allows different materials to be exercised by different constitutive
models without changing parameters.
\end{notice}

An example \code{material} input block for an elastic material would look like:

\begin{Verbatim}[commandchars=\\\{\}]
begin material
  constitutive model elastic
  bkmod 130.e9
  shmod 57.e9
end material
\end{Verbatim}


\subsection{The \texttt{boundary} Block}
\label{Files/input_file_formatting:the-boundary-block}\label{Files/input_file_formatting:boundary-block}
In the \code{boundary} block, the boundary conditions for the simulation are
defined. The \code{boundary} block is comprised of keyword instructions to
\emph{Payette} and a \code{legs} block. In the \code{boundary} block below, the default
values for available keywords are shown:

\begin{Verbatim}[commandchars=\\\{\}]
begin boundary
  kappa = 0.
  ampl = 1.
  ratfac = 1.
  tstar = 1.
  sstar = 1.
  estar = 1.
  fstar = 1.
  dstar = 1.
  efstar = 1.
  stepstar = 1.
  emit = all \PYGZob{}all,sparce\PYGZcb{}
  screenout = false \PYGZob{}true,false\PYGZcb{}
  nprints = 0 \PYGZob{}0-nsteps\PYGZcb{}
  begin legs
    \textless{}leg no\textgreater{} \textless{}time\textgreater{} \textless{}nsteps\textgreater{} \textless{}ltyp\textgreater{}  \textless{}c[ij]\textgreater{}
  end legs
end boundary
\end{Verbatim}

The various keywords and the \code{legs} block are described in the following sections.


\subsection{The \texttt{boundary} Block Keywords}
\label{Files/input_file_formatting:the-boundary-block-keywords}\label{Files/input_file_formatting:legs-keywords}\phantomsection\label{Files/input_file_formatting:xstar-keywords}

\begin{fulllineitems}
\pysigline{\bfcode{{[}t,s,e,f,d,ef,step{]}star}}
\end{fulllineitems}


Multiplier on all components of time, stress, strain, deformation gradient,
strain rate, displacement, electric field, and number of steps, respectively. All
values of the previously listed quantities are defined in each leg will be
multiplied by this factor. As an example, if the simulation times are given in
microseconds, \code{tstar} could be set to \code{1.0e-6} and the times given in integer
microsecond values.
\phantomsection\label{Files/input_file_formatting:emit-keyword}\index{emit (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/input_file_formatting:emit}\pysigline{\bfcode{emit}}
\end{fulllineitems}


Write all data (\code{emit = all}) or data from only 10 timesteps (\code{emit =
sparse}) to the output file.
\phantomsection\label{Files/input_file_formatting:screenout-keyword}\index{screenout (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/input_file_formatting:screenout}\pysigline{\bfcode{screenout}}
\end{fulllineitems}


Print out all timestep information to the console.
\phantomsection\label{Files/input_file_formatting:nprints-keyword}\index{nprints (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/input_file_formatting:nprints}\pysigline{\bfcode{nprints}}
\end{fulllineitems}


Total number of writes to the output file during the simulation.
\phantomsection\label{Files/input_file_formatting:ampl-keyword}\index{ampl (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/input_file_formatting:ampl}\pysigline{\bfcode{ampl}}
\end{fulllineitems}


Multiplier on all leg inputs. \code{ampl} may be used to increase or decrease the
peak values of the given inputs without changing the rates of those inputs.
\phantomsection\label{Files/input_file_formatting:ratfac-keyword}\index{ratfac (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/input_file_formatting:ratfac}\pysigline{\bfcode{ratfac}}
\end{fulllineitems}


Multiplier on strain and stress rates - effectively achieved by dividing each
time by \code{ratfac}.
\phantomsection\label{Files/input_file_formatting:kappa-keyword}\index{kappa (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/input_file_formatting:kappa}\pysigline{\bfcode{kappa}}
\end{fulllineitems}


The keyword \code{kappa} is only used/defined for the purposes of strain or strain
rate control. It refers to the coefficient used in the Seth-Hill generalized
strain definition
\begin{gather}
\begin{split}[\varepsilon] = \frac{1}{\kappa}\left( [U]^\kappa - [I]\right)\end{split}\notag
\end{gather}
Where $\kappa$ is the keyword \code{kappa}, $[\varepsilon]$ is the
strain tensor, $[U]$ is the right Cauchy stretch tensor, and $[I]$ is
the identity tensor. Common values of $\kappa$ and the associated common
names for each (there is some ambiguity in the names) are:
\begin{quote}

\begin{tabulary}{\linewidth}{|c|l|}
\hline
\textbf{
$\kappa$
} & \textbf{
Name(s)
}\\\hline

$-2$
 & 
Green
\\\hline

$-1$
 & 
True, Cauchy
\\\hline

$0$
 & 
Logarithmic, Hencky, True
\\\hline

$1$
 & 
Engineering, Swainger
\\\hline

$2$
 & 
Lagrange, Almansi
\\\hline
\end{tabulary}

\end{quote}


\subsection{The \texttt{legs} Block}
\label{Files/input_file_formatting:legs-block}\label{Files/input_file_formatting:the-legs-block}
The \code{legs} block defines the material states that will be applied to the
single element during each ``\code{leg}'' of the simulation. Legs may be defined in
one of two ways: 1) a general method in which all of the control parameters of
each leg are explicitly defined or, 2) time, deformation type table. Each method
of specifying \code{legs} is described below.


\subsubsection{General Leg Specification}
\label{Files/input_file_formatting:general-leg-specification}
In the most general case, each leg will be defined as follows:

\begin{Verbatim}[commandchars=\\\{\}]
begin legs
  \textless{}leg no\textgreater{} \textless{}time\textgreater{} \textless{}nsteps\textgreater{} \textless{}ltyp\textgreater{}  \textless{}c[ij]\textgreater{}
end legs
\end{Verbatim}

The \code{leg no} or leg number is a strictly monotonically increasing integer,
starting from zero for the first leg. There can be an arbitrary number of legs
defined.

The value \code{time} defines at what time in the simulation the material state will
be as it is defined in that leg. Generally the first leg (leg zero) will have a
time equal to 0 (seconds, microseconds, etc.). The values of time must increase
strictly monotonically with leg number.

The value of \code{nsteps} is an integer that defines the number of steps the
simulation will take to get from the previous leg to the current leg. Currently,
it is not possible to explicitly define a timestep for the single element tests.
However, by setting the time increment and value of \code{nsteps} you can set the
timestep size for that leg.

The value of \code{ltyp} or leg type is a little more involved. This keyword
frequently has more features added to it, most of which are experimental.
However, in this document only the most basic and stable options will be
addressed.

The basic form of the leg type is a string that specifies the material state for
specific components by setting each character to one of the following
\begin{itemize}
\item {} 
\textbf{1}: strain rate control (mech,6)

\item {} 
\textbf{2}: strain control (mech,6)

\item {} 
\textbf{3}: stress rate control (mech,6)

\item {} 
\textbf{4}: stress control (mech,6)

\item {} 
\textbf{5}: deformation gradient control (mech,9)

\item {} 
\textbf{6}: electric field (elec,3)

\item {} 
\textbf{8}: displacement (mech,3)

\end{itemize}

There are two types of control here: mechanics control (mech) and electric field
control (elec). Because these two types are seperated and handled individually
after parsing, the mechanics and electric control characters can be mixed
together without change in behavior. The integer given in the parentheses in the
above list represent the maximum number of components that may be defined. The
user must define at least three mechanics options for any given simulation. If no
electric field options are given, they default to zero.

Once the mechanics control characters are gathered, they are checked for
compatibility. Specifically, the rules are as follows:
\begin{itemize}
\item {} 
Deformation gradient control (5) cannot be mixed with other mechanics control
options and all 9 components must be defined.

\item {} 
Displacement control (8) cannot be mixed with other mechanics control
options.

\end{itemize}

Then, the component values \code{c{[}ij{]}} are read in and are assigned values based on
the leg type string. For symmetric second order tensors, the \code{c{[}ij{]}} user input
components correlating to tensor components by
\begin{gather}
\begin{split}[C] = \begin{bmatrix}
       C_{1} & C_{4} & C_{6} \\
             & C_{2} & C_{5} \\
             &       & C_{3}
      \end{bmatrix}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
For general second order tensors, the \code{c{[}ij{]}} user input components correlating
to tensor components by
\begin{gather}
\begin{split}[C] = \begin{bmatrix}
       C_{1} & C_{2} & C_{3} \\
       C_{4} & C_{5} & C_{6} \\
       C_{7} & C_{8} & C_{9}
      \end{bmatrix}\end{split}\notag\\\begin{split}\end{split}\notag
\end{gather}
\emph{Payette} simply follows this pattern for assigning variables. However, at
least the first three must be defined (the $x$, $y$, and $z$
components). If any variables are given beyond this, it fills in the matrix in
that order up to the maximum number of components.


\subsubsection{Time/Deformation Type Tables}
\label{Files/input_file_formatting:time-deformation-type-tables}
In the event that the deformation control type is constant for all legs (e.g.,
all legs are strain controlled), a more convenient method of defining each leg
is through specifying a time/deformation type table. In this specialized case,
the legs block is defined as:

\begin{Verbatim}[commandchars=\\\{\}]
begin legs
  using \textless{}time,dt\textgreater{}, \textless{}deformation type\textgreater{}
  \textless{}time,dt\textgreater{} components of deformation...
                 .
                 .
                 .
  \textless{}time,dt\textgreater{} components of deformation...
end legs
\end{Verbatim}

This method of input is convenient for reading in history files from finite
element simulations, or data collection software.


\subsection{\texttt{legs} Examples}
\label{Files/input_file_formatting:legs-examples}

\subsubsection{Example 1: Deformation Gradient, Uniaxial Extension}
\label{Files/input_file_formatting:example-1}\label{Files/input_file_formatting:example-1-deformation-gradient-uniaxial-extension}
This example extends the material in the $x$-direction:

\begin{Verbatim}[commandchars=\\\{\}]
begin legs
  0, 0.0, 0, 555555555, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0
  1, 1.0, 1, 555555555, 1.1, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0
end legs
\end{Verbatim}


\subsubsection{Example 2: Strain Control, Uniaxial Extension}
\label{Files/input_file_formatting:example-2}\label{Files/input_file_formatting:example-2-strain-control-uniaxial-extension}
All of the following produce equivalent behavior (uniaxial strain extension).
Remember to set \code{kappa} to the desired value.:

\begin{Verbatim}[commandchars=\\\{\}]
begin legs
  0, 0.0, 0, 222222, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0
  1, 1.0, 1, 222222, 0.1, 0.0, 0.0, 0.0, 0.0, 0.0
end legs
\end{Verbatim}


\subsubsection{Example 3: Stress Control, Uniaxial Tension}
\label{Files/input_file_formatting:example-3-stress-control-uniaxial-tension}\label{Files/input_file_formatting:example-3}
Stress control can be defined in much the same way as strain control (see example
2). Assuming that the material parameters are defined in MKS, stress will be
defined in terms of Pa.:

\begin{Verbatim}[commandchars=\\\{\}]
begin legs
  0, 0.0, 0, 444444, 0.0e9, 0.0, 0.0, 0.0, 0.0, 0.0
  1, 1.0, 0, 444444, 1.0e9, 0.0, 0.0, 0.0, 0.0, 0.0
end legs
\end{Verbatim}


\subsubsection{Example 4: Mixed Control}
\label{Files/input_file_formatting:example-4-mixed-control}\label{Files/input_file_formatting:example-4}
This example could be used to reproduce the stress state found in the standard
tension test when the strain is known. Specifically, we prescribe the strain
value in the $x$-direction while prescribing the lateral stresses to be
held at zero stress.:

\begin{Verbatim}[commandchars=\\\{\}]
begin legs
  0, 0.0, 0, 244222, 0.00, 0.0, 0.0, 0.0, 0.0, 0.0
  1, 1.0, 0, 244222, 0.01, 0.0, 0.0, 0.0, 0.0, 0.0
end legs
\end{Verbatim}

\begin{notice}{note}{Note:}
As prescribed stress is essentially an inverse problem, prescribed stress
simulations take much longer than prescribed strain simulations. This is due
to the need of using optimization routines to determine the correct strain
increment to input to the material model.

The general objective function used in the optimization routine is simply an
L2 norm of the difference of the prescribed stress components with the output
stress components. This is of particular importance when a stress is
prescribed outside of the limit surface for a material and the material stress
simply cannot reach the prescribed stress. For example, if the user desired
uniaxial stress but prescribed the stress to some value beyond the limit
surface then the stress state might develop non-zero values in components that
could reasonably be expected to stay zero.

To alleviate this problem, \emph{Payette} has a command line argument
\code{-{-}proportional} that enforces proportional loading for prescribed stress
problems. This changes the objective function to optimize for a stress state
that is proportional to the prescribed stress by some factor and that is as
close as possible to the prescribed stress. Specifically, it decomposes the
output stress tensor into \code{proportional} and \code{perpendicular} tensors with
the proportional stress tensor begin a multiple of the prescribed stress
tensor and the perpendicular tensor being the balance. The function takes the
square of the L2 norm of the perpendicular tensor and the L2 norm of the
difference of the proportional and prescribed tensors. In this way \emph{Payette}
weights the stress state such that being proportional is more important than
being closer. For this objective function using the same simulation as
described for the default objective function, we would maintain uniaxial
stress even when the limit surface is attained.
\end{notice}

\begin{notice}{warning}{Warning:}
Stress control (especially proportional loading) can introduce excessive noise
when stress states are prescribed outside of the yield surface. However, it
can also perform flawlessly. Be aware of the limits of the objective functions
when choosing.
\end{notice}


\subsubsection{Example 5: Using Time/Deformation Type Table}
\label{Files/input_file_formatting:example-5-using-time-deformation-type-table}\label{Files/input_file_formatting:example-5}
In this example, the strain path of {\hyperref[Files/input_file_formatting:example-2]{\emph{Example 2: Strain Control, Uniaxial Extension}}} is specified with a time,
strain table

\begin{Verbatim}[commandchars=\\\{\}]
begin legs
  using time, strain
  0. 0.0 0.0 0.0 0.0 0.0 0.0
  1. 0.1 0.0 0.0 0.0 0.0 0.0
end legs
\end{Verbatim}


\subsubsection{Example 6: Using dt/Deformation Type Table}
\label{Files/input_file_formatting:example-6-using-dt-deformation-type-table}
In this example, the strain path of {\hyperref[Files/input_file_formatting:example-2]{\emph{Example 2: Strain Control, Uniaxial Extension}}} is specified with a time
step, strain table

\begin{Verbatim}[commandchars=\\\{\}]
begin legs
  using dt, strain
  0. 0.0 0.0 0.0 0.0 0.0 0.0
  .1 0.1 0.0 0.0 0.0 0.0 0.0
end legs
\end{Verbatim}


\section{Optional Blocks}
\label{Files/input_file_formatting:optional-blocks}\label{Files/input_file_formatting:id3}
The following blocks are optional: \code{mathplot} \code{enumerate}.


\subsection{\texttt{mathplot} Block}
\label{Files/input_file_formatting:mathplot-block}
The \code{mathplot} block is used to specify optional plotting information written
to the \code{simnam.math{[}1,2{]}} output files for use in Rebecca Brannon's
Mathematica post processing files. The basic syntax is:

\begin{Verbatim}[commandchars=\\\{\}]
begin mathplot
  var1 var2 var3
  var4, var5, var6
  var7; ...; varn
end mathplot
\end{Verbatim}

where \code{var?} are \emph{Payette} and material model variables. A complete list of
plotable variables is listed in each simulation's log file. Each line in the
\code{mathplot} block can contain an arbitrary number of space, comma, or semi-colon
delimited variables.


\subsection{\texttt{enumeration} Block}
\label{Files/input_file_formatting:enumeration-block}
The \code{enumeration} block is used to run a batch of simulations that are
very similar to the base input given. The basic syntax is:

\begin{Verbatim}[commandchars=\\\{\}]
begin enumeration
  enumerate PARAM1 VAL1 VAL2 VAL3 ...
  enumerate PARAM2 VAL4 VAL5 VAL6 ...
  ...
end enumeration
\end{Verbatim}

This would take the general input and spawn simulations where the value associated
with PARAM1 is replace by VAL1 and the value associated with PARAM2 is replaced by
VAL4, then another simulation where PARAM1-\textgreater{}VAL2 and PARAM2-\textgreater{}VAL5, etc.

Directories containing each individual simulation and its output are put into a
general directory called \code{SIMNAME.enum} with the individual simulations being
contained in subdirectories named \code{job.X} where the \code{SIMNAME} is the simulation
name defined in the first line of the input file (\code{begin simulation SIMNAME}) and \code{X} is
replaced by the index of the job being run.


\section{Inserting External Files}
\label{Files/input_file_formatting:inserting-files}\label{Files/input_file_formatting:inserting-external-files}
External files containing formatted \emph{Payette} input can be included anywhere in
the input file through the \code{include} and \code{insert} directives. For
example, material parameters can be kept in a separate parameter file and
inserted in to an input file by:

\begin{Verbatim}[commandchars=\\\{\}]
begin material
  constitutive model kayenta
  insert salem\_limestone.dat
end material
\end{Verbatim}

When \emph{Payette} encounters an \code{{[}insert,include{]}} directive, it looks for the
inserted file by it's absolute path, in the current directory, and in the
\code{PAYETTE\_ROOT/Aux/MaterialsDatabase} directory, in that order.
\phantomsection\label{Files/input_file_formatting:examples}

\section{Example: A Complete Input File}
\label{Files/input_file_formatting:complete-input-file}\label{Files/input_file_formatting:example-a-complete-input-file}\label{Files/input_file_formatting:examples}
Below is an input file, any keywords not given take the default values shown in
{\hyperref[Files/input_file_formatting:legs-keywords]{\emph{The boundary Block Keywords}}}. In this input file, a material defined by the \code{elastic}
constitutive model is cycled through the same deformation path by first
prescribing the strain, then the stress, strain rate, stress rate, and finally
the deformation gradient.

\begin{Verbatim}[commandchars=\\\{\}]
begin simulation elastic unistrain cycle

  begin material
    constitutive model elastic
    shmod 53.e9
    bkmod 135.e9
  end material

  begin boundary
    kappa = 0.
    tfac = 1.
    amplitude = 1

    begin legs
    \# l  t   n     ltyp       c[ij]...
      0, 0., 0.,   222222,    0., 0., 0., 0., 0., 0.
      1, 1., 100,  222222,    .1, 0., 0., 0., 0., 0.
      2, 2., 100,  222222,    0., 0., 0., 0., 0., 0.
      3, 3., 100,  444444,    20.566e9, 9.966e9, 9.966e9, 0., 0., 0.
      4, 4., 100,  444444,    0. ,0. ,0. ,0. ,0. ,0.
      5, 5., 100,  111111,    0.1 ,0. ,0. ,0. ,0. ,0.
      6, 6., 100,  111111,   -0.1 ,0. ,0. ,0. ,0. ,0.
      7, 7., 100,  333333,    20.566e9, 9.966e9, 9.966e9, 0., 0., 0.
      8, 8., 100,  333333,   -20.566e9, -9.966e9, -9.966e9, 0., 0., 0.
      9, 9., 100,  555555555, 1.1052, 1., 1., 0., 0., 0., 0., 0., 0.
     10, 10.,100,  555555555, 1., 1., 1., 0., 0., 0., 0., 0., 0.
    end legs

  end boundary

  begin mathplot
    sig11 sig22 sig33
    eps11 eps22 eps33
  end mathplot
end simulation
\end{Verbatim}


\chapter{Running Tests}
\label{Files/test_payette:running-tests}\label{Files/test_payette::doc}
\emph{Payette} provides a mechanism for running material model regression tests with
the \code{testPayette} script. \code{testPayette} is what makes \emph{Payette} an
invaluable tool to material model development. Simplistically,
\code{testPayette} is a tool that exercises \code{runPayette} on previously
setup simulations and compares the output against a ``gold'' result, allowing model
developers to instantly see if and how changes to a material model effect its
output.


\section{Basic Usage of \texttt{testPayette}}
\label{Files/test_payette:basic-usage-of-testpayette}
From a command prompt execute:

\begin{Verbatim}[commandchars=\\\{\}]
\% testPayette
\end{Verbatim}

\code{testPayette} will scan \code{PAYETTE\_ROOT/Tests} for tests. After
creating a lists of tests to run, \code{testPayette} will create a
\code{PWD/TestResults.OSTYPE} directory and subdirectories in which the tests
will be run. The subdirectories created in \code{PWD/TestResults.OSTYPE/} mirror
the subdirectories of \code{PAYETTE\_ROOT/Tests}. After creating the
\code{PWD/TestResults.OSTYPE/} directory tree, it will then move in to the
appropriate subdirectory to run and analyze each individual test. For example, if
the \code{Tests/Materials/Elastic/elastic-unistrain.py} test is run,
\code{testPayette} will create a
\code{PWD/TestResults.OSTYPE/Materials/Elastic/elastic-unistrain/} directory,
move to it, and run the \code{elastic-unistrain.py} test in it.


\subsection{Filtering Tests to Run}
\label{Files/test_payette:filtering-tests-to-run}
The tests run can be filtered by keyword with the \code{-k} option. For example, to
run only the \code{fast} \code{kayenta} material tests, execute:

\begin{Verbatim}[commandchars=\\\{\}]
\% testPayette -k kayenta -k fast
\end{Verbatim}

Or, you can run specific tests with the \code{-t} option. For example, to run only
the \code{elastic-unistrain.py} test, execute:

\begin{Verbatim}[commandchars=\\\{\}]
\% testPayette -t elastic-unistrain
\end{Verbatim}


\section{Multiprocessor Support}
\label{Files/test_payette:multiprocessor-support}
By default, \code{testPayette} will run all collected tests serially on a single
processor, but supports running tests on multiple processors with the \code{-j
nproc} option, where \code{nproc} is the number of processors. For example, to run
all of the kayenta tests on 8 processors, execute:

\begin{Verbatim}[commandchars=\\\{\}]
\% testPayette -k kayenta -j8
\end{Verbatim}

\begin{notice}{warning}{Warning:}
When run on multiple processors, you cannot kill \code{testPayette} by
\code{ctrl-c}, but must put the job in the background and then kill it. Any help
from a python multiprocessor expert on getting around this limitation would be
greatly appreciated!
\end{notice}


\section{Other \texttt{testPayette} Options}
\label{Files/test_payette:other-testpayette-options}
Execute:

\begin{Verbatim}[commandchars=\\\{\}]
\% testPayette -h
\end{Verbatim}

for a complete list of options.


\section{html Test Summary}
\label{Files/test_payette:html-test-summary}
\code{testPayette} gives a complete summary of test results in
\code{TestResults.OSTYPE/summary.html} viewable in any web browser.


\section{Mathematca Post Processing}
\label{Files/test_payette:mathematca-post-processing}
For the Kayenta material model, \code{testPayette} creates Rebecca Brannon's
Mathematica post processing file \code{kayenta.nb} (formerly \code{030626.nb})
in \code{PWD/TestResults.OSTYPE/Materials/Kayenta/}, that aids greatly in
analyzing test results for the Kayenta material model.


\section{Creating New Tests}
\label{Files/test_payette:creating-new-tests}
\begin{notice}{note}{Todo}

need to add this section
\end{notice}


\chapter{Installing New Materials}
\label{Files/installing_materials::doc}\label{Files/installing_materials:installing-new-materials}
\emph{Payette} was born from the need for an environment in which material
constitutive models could be rapidly developed, tested, deployed, and maintained,
independent of host finite element code implementation. Important prerequisites
in the design of \emph{Payette} were ease of model installation and support for
constitutive routines written in Fortran. This requirement is met by providing a
simple API with which a model developer can install a material in \emph{Payette} as
a new Python class and use \href{http://www.scipy.org/F2py}{f2py} to compile
Python extension modules from the material's Fortran source (if applicable). In
this section, the required elements of the constitutive model interface and
instructions on compiling the material's Fortran source (if applicable) are
provided.


\section{Material File Naming Conventions}
\label{Files/installing_materials:material-file-naming-conventions}
Each material model must provide its Python class definition in an ``interface''
file in the \code{PAYETTE\_ROOT/Source/Materials}. The accepted naming convention
for the material's interface file is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PAYETTE\PYGZus{}ROOT}\PYG{o}{/}\PYG{n}{Source}\PYG{o}{/}\PYG{n}{Materials}\PYG{o}{/}\PYG{n}{Payette\PYGZus{}material\PYGZus{}name}\PYG{o}{.}\PYG{n}{py}
\end{Verbatim}

A material's Fortran source code (if applicable) is stored in its own directory
in the \code{PAYETTE\_ROOT/Source/Materials/Fortran} directory. The accepted
naming convention for the material's Fortran directory is:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PAYETTE\PYGZus{}ROOT}\PYG{o}{/}\PYG{n}{Source}\PYG{o}{/}\PYG{n}{Materials}\PYG{o}{/}\PYG{n}{Fortran}\PYG{o}{/}\PYG{n}{MaterialName}
\end{Verbatim}

There is no defined naming convention for Fortran source code within the
materials \code{Fortran/MaterialName} directory.

As an example, suppose you were developing a new material model ``Porous Rock''.
The source files and directories would be named:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{PAYETTE\PYGZus{}ROOT}\PYG{o}{/}\PYG{n}{Source}\PYG{o}{/}\PYG{n}{Materials}\PYG{o}{/}\PYG{n}{Payette\PYGZus{}porous\PYGZus{}rock}\PYG{o}{.}\PYG{n}{py}
\PYG{n}{PAYETTE\PYGZus{}ROOT}\PYG{o}{/}\PYG{n}{Source}\PYG{o}{/}\PYG{n}{Materials}\PYG{o}{/}\PYG{n}{Fortran}\PYG{o}{/}\PYG{n}{PorousRock}
\end{Verbatim}

\begin{notice}{note}{Note:}
The \emph{Payette} project is an open source project, without restrictions on how
the source code is used and/or distributed. However, many material models do
have restrictive access controls and cannot, therefore, include their source
files in \emph{Payette}. This is the case for many materials currently being
developed with \emph{Payette}. For these materials, rather than include the source
code in the material's Fortran directory, the Fortran build script used by
\emph{Payette} to build the material's Python extension module is used to direct
\emph{Payette} to the location of the material's source files, elsewhere in the
developer's file system. The contents of the Fortran build script are
discussed later in this document in the section on building Fortran source
code in \emph{Payette}.
\end{notice}


\section{Interface File Required Attributes}
\label{Files/installing_materials:interface-file-required-attributes}
The interface file must provide an \code{attributes} with the following keys


\begin{fulllineitems}
\pysigline{\bfcode{attributes{[}''payette~material''{]}}}
Boolean.  Does the material represent an interface file, or not.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\bfcode{attributes{[}''name''{]}}}
String.  The material name.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\bfcode{attributes{[}''fortran~source''{]}}}
Boolean.  Does the material have additional Fortran source code.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\bfcode{attributes{[}''build~script''{]}}}
String.  Absolute path to Fortran build script, if applicable.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\bfcode{attributes{[}''aliases''{]}}}
List.  List of optional names.

\end{fulllineitems}



\begin{fulllineitems}
\pysigline{\bfcode{attributes{[}''material~type''{]}}}
List. List of keyword descriptors of material type. Examples are ``mechanical'',
``electro-mechanical''.

\end{fulllineitems}


\begin{notice}{note}{Note:}
Using the \code{attributes} dictionary outside of the material's class definition
allows \emph{Payette} to scan \code{PAYETTE\_ROOT/Source/Materials/} directory to
find and import only the \emph{Payette} material interface files during the build
process.
\end{notice}


\section{Constitutive Model API: Required Elements}
\label{Files/installing_materials:constitutive-model-api-required-elements}
\emph{Payette} provides a simple interface for interacting with material models
through the Python class structure. Material models are installed as separate
Python classes, derived from the \code{ConstitutiveModelPrototype} base class.


\subsection{Inheritance From Base Class}
\label{Files/installing_materials:inheritance-from-base-class}
A new material model \code{MaterialModel} is only recognized as a material model by
Payette if it inherits from the \code{ConstitutiveModelPrototype} base class:

\begin{Verbatim}[commandchars=\\\{\}]
class MaterialModel(ConstitutiveModelPrototype):
\end{Verbatim}


\subsection{Required Data}
\label{Files/installing_materials:required-data}\index{MaterialModel.aliases (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.aliases}\pysigline{\code{MaterialModel.}\bfcode{aliases}}
The aliases by which the constitutive model can be called (case insensitive).

\end{fulllineitems}

\index{MaterialModel.bulk\_modulus (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.bulk_modulus}\pysigline{\code{MaterialModel.}\bfcode{bulk\_modulus}}
The bulk modulus.  Used for determining the material's Jacobian matrix

\end{fulllineitems}

\index{MaterialModel.imported (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.imported}\pysigline{\code{MaterialModel.}\bfcode{imported}}
Boolean indicating whether the material's extension library (if applicable)
was imported.

\end{fulllineitems}

\index{MaterialModel.name (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.name}\pysigline{\code{MaterialModel.}\bfcode{name}}
The name by which users can invoke the constituve model from the input file
(case insensitive).

\end{fulllineitems}

\index{MaterialModel.nprop (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.nprop}\pysigline{\code{MaterialModel.}\bfcode{nprop}}
The number of required parameters for the model.

\end{fulllineitems}

\index{MaterialModel.shear\_modulus (built-in variable)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.shear_modulus}\pysigline{\code{MaterialModel.}\bfcode{shear\_modulus}}
The shear modulus.  Used for determining the material's Jacobian matrix

\end{fulllineitems}



\subsection{Required Functions}
\label{Files/installing_materials:required-functions}\index{MaterialModel.\_\_init\_\_() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.__init__}\pysiglinewithargsret{\code{MaterialModel.}\bfcode{\_\_init\_\_}}{}{}
Instantiate the material model.  Register parameters with \emph{Payette}.

\end{fulllineitems}

\index{MaterialModel.setUp() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.setUp}\pysiglinewithargsret{\code{MaterialModel.}\bfcode{setUp}}{\emph{simdat}, \emph{matdat}, \emph{user\_params}, \emph{f\_params}}{}
Check user inputs and register extra variables with \emph{Payette}. \emph{simdat} and
\emph{matdat} are the simulation and material data containers, respectively,
\emph{user\_params} are the parameters read in from the input file, and \emph{f\_params}
are parameters from a parameters file.

\end{fulllineitems}

\index{MaterialModel.updateState() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:MaterialModel.updateState}\pysiglinewithargsret{\code{MaterialModel.}\bfcode{updateState}}{\emph{simdat}, \emph{matdat}}{}
Update the material state to the end of the current time step. \emph{simdat} and
\emph{matdat} are the simulation and material data containers, respectively.

\end{fulllineitems}



\section{Example: Elastic Material Model Interface File}
\label{Files/installing_materials:example-elastic-material-model-interface-file}
The required elements of the material's interface file described above are now
demonstrated by an annotated version of the elastic material's interface.

\textbf{View the source code:}
\code{Payette\_elastic.py}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}

\PYG{k+kn}{from} \PYG{n+nn}{Source.Payette\PYGZus{}utils} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{Source.Payette\PYGZus{}constitutive\PYGZus{}model} \PYG{k+kn}{import} \PYG{n}{ConstitutiveModelPrototype}
\end{Verbatim}

\begin{notice}{note}{Note:}
The \code{Source.Payette\_utils} module contains public methods for interfacing
with \emph{Payette}.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{attributes} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s}{"}\PYG{l+s}{payette material}\PYG{l+s}{"}\PYG{p}{:}\PYG{n+nb+bp}{True}\PYG{p}{,}
    \PYG{l+s}{"}\PYG{l+s}{name}\PYG{l+s}{"}\PYG{p}{:}\PYG{l+s}{"}\PYG{l+s}{elastic}\PYG{l+s}{"}\PYG{p}{,}
    \PYG{l+s}{"}\PYG{l+s}{fortran source}\PYG{l+s}{"}\PYG{p}{:}\PYG{n+nb+bp}{True}\PYG{p}{,}
    \PYG{l+s}{"}\PYG{l+s}{build script}\PYG{l+s}{"}\PYG{p}{:}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{Payette\PYGZus{}Materials\PYGZus{}Fortran}\PYG{p}{,}\PYG{l+s}{"}\PYG{l+s}{Elastic/build.py}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{,}
    \PYG{l+s}{"}\PYG{l+s}{aliases}\PYG{l+s}{"}\PYG{p}{:}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{hooke}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+s}{"}\PYG{l+s}{elasticity}\PYG{l+s}{"}\PYG{p}{]}\PYG{p}{,}
    \PYG{l+s}{"}\PYG{l+s}{material type}\PYG{l+s}{"}\PYG{p}{:}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{mechanical}\PYG{l+s}{"}\PYG{p}{]}
    \PYG{p}{\PYGZcb{}}

\PYG{k}{try}\PYG{p}{:}
    \PYG{k+kn}{import} \PYG{n+nn}{Source.Materials.Library.elastic} \PYG{k+kn}{as} \PYG{n+nn}{mtllib}
    \PYG{n}{imported} \PYG{o}{=} \PYG{n+nb+bp}{True}
\PYG{k}{except}\PYG{p}{:}
    \PYG{n}{imported} \PYG{o}{=} \PYG{n+nb+bp}{False}
    \PYG{k}{pass}
\end{Verbatim}

\begin{notice}{note}{Note:}
We don't raise an exception just yet if the material's extension library is
not importable. This allows users to run simulations even if all materials
were not imported. Of course, if you try to run a simulation with a material
that is not imported, an exception is raised.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{Elastic}\PYG{p}{(}\PYG{n}{ConstitutiveModelPrototype}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{    CLASS NAME}
\PYG{l+s+sd}{       Elastic}

\PYG{l+s+sd}{    PURPOSE}
\PYG{l+s+sd}{       Constitutive model for an elastic material. When instantiated, the Elastic}
\PYG{l+s+sd}{       material initializes itself by first checking the user input}
\PYG{l+s+sd}{       (\PYGZus{}check\PYGZus{}props) and then initializing any internal state variables}
\PYG{l+s+sd}{       (\PYGZus{}set\PYGZus{}field). Then, at each timestep, the driver update the Material state}
\PYG{l+s+sd}{       by calling updateState.}

\PYG{l+s+sd}{    METHODS}
\PYG{l+s+sd}{       Private:}
\PYG{l+s+sd}{         \PYGZus{}check\PYGZus{}props}
\PYG{l+s+sd}{         \PYGZus{}set\PYGZus{}field}

\PYG{l+s+sd}{       Public:}
\PYG{l+s+sd}{         setUp}
\PYG{l+s+sd}{         updateState}

\PYG{l+s+sd}{    FORTRAN}
\PYG{l+s+sd}{       The core code for the Elastic material is contained in}
\PYG{l+s+sd}{       Fortran/Elastic/elastic.f.  The module Library/elastic is created by f2py.}
\PYG{l+s+sd}{       elastic.f defines the following public subroutines}

\PYG{l+s+sd}{          hookechk: fortran data check routine called by \PYGZus{}check\PYGZus{}props}
\PYG{l+s+sd}{          hookerxv: fortran field initialization  routine called by \PYGZus{}set\PYGZus{}field}
\PYG{l+s+sd}{          hooke\PYGZus{}incremental: fortran stress update called by updateState}

\PYG{l+s+sd}{       See the documentation in elastic.f for more information.}

\PYG{l+s+sd}{    AUTHORS}
\PYG{l+s+sd}{       Tim Fuller, Sandia National Laboratories, tjfulle@sandia.gov}
\PYG{l+s+sd}{    """}
    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{ConstitutiveModelPrototype}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
The base ConstitutiveModelPrototype class must be initialized.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{=} \PYG{n}{attributes}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{name}\PYG{l+s}{"}\PYG{p}{]}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{aliases} \PYG{o}{=} \PYG{n}{attributes}\PYG{p}{[}\PYG{l+s}{"}\PYG{l+s}{aliases}\PYG{l+s}{"}\PYG{p}{]}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{imported} \PYG{o}{=} \PYG{n}{imported}
\end{Verbatim}

\begin{notice}{note}{Note:}
The required elastic material data \code{name}, \code{aliases}, and \code{imported} are
assigned from the interface files \code{attributes} dictionary and the file scope
variable \code{imported}.
\end{notice}

\begin{notice}{note}{Note:}
Below, the elastic material's parameters are registered with \emph{Payette}
through the \code{registerParameter} function:
\index{self.registerParameter() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:self.registerParameter}\pysiglinewithargsret{\code{self.}\bfcode{registerParameter}}{\emph{name}, \emph{ui\_loc}, \emph{aliases=}\optional{}}{}
Register the parameter \emph{name} with \emph{Payette}. \emph{ui\_loc} is the integer
location (starting at 0) of the parameter in the material's user input array.
\emph{aliases} are aliases by which the parameter can be specified in the input
file.

\end{fulllineitems}

\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} register parameters}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{LAM}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{G}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{SHMOD}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{E}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{YMOD}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{NU}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{POISSONS}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{K}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{l+s}{'}\PYG{l+s}{BKMOD}\PYG{l+s}{'}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{H}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{KO}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{CL}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{7}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{CT}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{8}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{CO}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{9}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{CR}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{registerParameter}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{RHO}\PYG{l+s}{"}\PYG{p}{,}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{n}{aliases}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nprop} \PYG{o}{=} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parameter\PYGZus{}table}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ndc} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{k}{pass}
\end{Verbatim}

\begin{notice}{note}{Note:}
\code{self.ndc} is the number of derived constants.  This model has none.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} Public methods}
\PYG{k}{def} \PYG{n+nf}{setUp}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{simdat}\PYG{p}{,}\PYG{n}{matdat}\PYG{p}{,}\PYG{n}{user\PYGZus{}params}\PYG{p}{,}\PYG{n}{f\PYGZus{}params}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{iam} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{name} \PYG{o}{+} \PYG{l+s}{"}\PYG{l+s}{.setUp(self,material,props)}\PYG{l+s}{"}

    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{imported}\PYG{p}{:} \PYG{k}{return}

    \PYG{c}{\PYGZsh{} parse parameters}
    \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parseParameters}\PYG{p}{(}\PYG{n}{user\PYGZus{}params}\PYG{p}{,}\PYG{n}{f\PYGZus{}params}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
\code{parseParameters} passes the user input read from the input file to the
initial user input array \code{self.UI0}. There is not return value.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} check parameters}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{dc} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ndc}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ui} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}check\PYGZus{}props}\PYG{p}{(}\PYG{p}{)}
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nsv}\PYG{p}{,}\PYG{n}{namea}\PYG{p}{,}\PYG{n}{keya}\PYG{p}{,}\PYG{n}{sv}\PYG{p}{,}\PYG{n}{rdim}\PYG{p}{,}\PYG{n}{iadvct}\PYG{p}{,}\PYG{n}{itype} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}set\PYGZus{}field}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
\code{\_check\_props} and \code{\_set\_field} are private functions that check the user
input and assign initial values to extra variables.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{namea} \PYG{o}{=} \PYG{n}{parseToken}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nsv}\PYG{p}{,}\PYG{n}{namea}\PYG{p}{)}
\PYG{n}{keya} \PYG{o}{=} \PYG{n}{parseToken}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nsv}\PYG{p}{,}\PYG{n}{keya}\PYG{p}{)}

\PYG{c}{\PYGZsh{} register the extra variables with the payette object}
\PYG{n}{matdat}\PYG{o}{.}\PYG{n}{registerExtraVariables}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{nsv}\PYG{p}{,}\PYG{n}{namea}\PYG{p}{,}\PYG{n}{keya}\PYG{p}{,}\PYG{n}{sv}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
Above, the elastic material model registers its extra variables with the
material data container.
\index{DataContainer.registerExtraVariables() (built-in function)}

\begin{fulllineitems}
\phantomsection\label{Files/installing_materials:DataContainer.registerExtraVariables}\pysiglinewithargsret{\code{DataContainer.}\bfcode{registerExtraVariables}}{\emph{nxv}, \emph{namea}, \emph{keya}, \emph{exinit}}{}
Register extra varaibles with the data container. \emph{nxv} is the number of
extra variables, \emph{namea} and \emph{keya} are ordered lists of extra variable
names and plot keys, respectively, and \emph{exinit} is a list of initial
values.

\end{fulllineitems}

\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{bulk\PYGZus{}modulus}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{shear\PYGZus{}modulus} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ui}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ui}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{k}{pass}
\end{Verbatim}

\begin{notice}{note}{Note:}
By default, \emph{Payette} computes the material's Jacobian matrix numerically
through a central difference algorithm. For some materials, like this elastic
model, the Jacobian is constant. Here, we redefine the Jacobian to return the
intial value.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZsh{} redefine Jacobian to return initial jacobian}
\PYG{k}{def} \PYG{n+nf}{jacobian}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{simdat}\PYG{p}{,}\PYG{n}{matdat}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{imported}\PYG{p}{:} \PYG{k}{return}
    \PYG{n}{v} \PYG{o}{=} \PYG{n}{simdat}\PYG{o}{.}\PYG{n}{getData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{prescribed stress components}\PYG{l+s}{"}\PYG{p}{)}
    \PYG{k}{return} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{J0}\PYG{p}{[}\PYG{p}{[}\PYG{p}{[}\PYG{n}{x}\PYG{p}{]} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{v}\PYG{p}{]}\PYG{p}{,}\PYG{n}{v}\PYG{p}{]}

\PYG{k}{def} \PYG{n+nf}{updateState}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{simdat}\PYG{p}{,}\PYG{n}{matdat}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{"""}
\PYG{l+s+sd}{       update the material state based on current state and strain increment}
\PYG{l+s+sd}{    """}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{imported}\PYG{p}{:} \PYG{k}{return}
\end{Verbatim}

\begin{notice}{note}{Note:}
The \emph{simdat} and \emph{matdat} data containers contain all current data. Data is
accessed by the \code{DataContainer.getData(name)} method.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{dt} \PYG{o}{=} \PYG{n}{simdat}\PYG{o}{.}\PYG{n}{getData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{time step}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{d} \PYG{o}{=} \PYG{n}{simdat}\PYG{o}{.}\PYG{n}{getData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{rate of deformation}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{sigold} \PYG{o}{=} \PYG{n}{matdat}\PYG{o}{.}\PYG{n}{getData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{stress}\PYG{l+s}{"}\PYG{p}{)}
\PYG{n}{svold} \PYG{o}{=} \PYG{n}{matdat}\PYG{o}{.}\PYG{n}{getData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{extra variables}\PYG{l+s}{"}\PYG{p}{)}

\PYG{n}{a} \PYG{o}{=} \PYG{p}{[}\PYG{n}{dt}\PYG{p}{,}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{ui}\PYG{p}{,}\PYG{n}{sigold}\PYG{p}{,}\PYG{n}{d}\PYG{p}{,}\PYG{n}{svold}\PYG{p}{,}\PYG{n}{migError}\PYG{p}{,}\PYG{n}{migMessage}\PYG{p}{]}
\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{Payette\PYGZus{}F2Py\PYGZus{}Callback}\PYG{p}{:} \PYG{n}{a} \PYG{o}{=} \PYG{n}{a}\PYG{p}{[}\PYG{p}{:}\PYG{o}{-}\PYG{l+m+mi}{2}\PYG{p}{]}
\PYG{n}{sig}\PYG{p}{,} \PYG{n}{sv}\PYG{p}{,} \PYG{n}{usm} \PYG{o}{=} \PYG{n}{mtllib}\PYG{o}{.}\PYG{n}{hooke\PYGZus{}incremental}\PYG{p}{(}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}
\end{Verbatim}

\begin{notice}{note}{Note:}
\code{hooke\_incremental(*a)} is a Fortran subroutine that performs the actual
physics. Below, we store the update values of the extra variables and the
stress.
\end{notice}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{matdat}\PYG{o}{.}\PYG{n}{storeData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{extra variables}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{sv}\PYG{p}{)}
\PYG{n}{matdat}\PYG{o}{.}\PYG{n}{storeData}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{stress}\PYG{l+s}{"}\PYG{p}{,}\PYG{n}{sig}\PYG{p}{)}

\PYG{k}{return}
\end{Verbatim}


\section{Building Material Fortran Extension Modules in \emph{Payette}}
\label{Files/installing_materials:building-material-fortran-extension-modules-in-payette}
\begin{notice}{note}{Note:}
This is not an exhaustive tutorial for how to link Python programs with
compiled source code. Instead, it demonstrates through an annotated example
the strategy that \emph{Payette} uses to build and link with material models
written in Fortran.
\end{notice}

The strategy used in \emph{Payette} to build and link to material models written in
Fortran is to use \emph{f2py} to compile the Fortran source in to a shared object
library recognized by Python. The same task can be accomplished through Python's
built in \href{http://docs.python.org/library/ctypes.html}{ctypes}, \href{http://www.scipy.org/Weave}{weave}, or other methods. We have found that \emph{f2py}
offers the most robust and easy to use solution. For more detailed examples of
how to use compiled libraries with Python see \href{http://docs.scipy.org/doc/numpy/user/c-info.python-as-glue.html}{Using Python as glue} at the SciPy
website or \href{http://www.sagemath.org/doc/numerical\_sage/using\_compiled\_code\_iteractively.html}{Using Compiled Code Interactively}
on Sage's website.

Rather than provide an exhaustive tutorial on linking Python programs to compiled
libraries, we demonstrate how the \code{elastic} material model accomplishes this
task through annotated examples.


\subsection{Creating the Elastic Material Signature File}
\label{Files/installing_materials:creating-the-elastic-material-signature-file}
First, a Python signature file for the \code{elatic} material's Fortran source must
be created. A signature file is a Fortran 90 file that contains all of the
information that is needed to construct Python bindings to Fortran (or C)
functions.

For the elastic model, change to
\code{PAYETTE\_ROOT/Source/Materials/Fortran/Elastic} and execute

\begin{Verbatim}[commandchars=\\\{\}]
\% f2py -m elastic -h elastic.signature.pyf elastic.F
\end{Verbatim}

which will create the \code{elastic.signature.pyf} signature file.

f2py will create a signature for every function in \code{elastic.F}. However,
only three public functions need to be bound to our Python program. So, after
creating the signature file, all of the signatures for the private functions can
safely be removed.

The signature file can be modified even further. See the above links on how to
specialize your signature file for maximum speed and efficiency.

\textbf{View the elastic.signature.pyf file:} \code{elastic.signauture.pyf}


\subsection{Elastic Material Build Script}
\label{Files/installing_materials:elastic-material-build-script}
Materials are built by \emph{f2py} through the \code{MaterialBuilder} class from which
each material derives its \code{Build} class. The \code{Build} class must provide a
\code{build\_extension\_module} function, as shown below in the elastic material's
build script.

\textbf{View the elastic material build script:} \code{build.py}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}\PYG{o}{,}\PYG{n+nn}{sys}

\PYG{k+kn}{from} \PYG{n+nn}{Payette\PYGZus{}config} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{k+kn}{from} \PYG{n+nn}{Source.Payette\PYGZus{}utils} \PYG{k+kn}{import} \PYG{n}{BuildError}
\PYG{k+kn}{from} \PYG{n+nn}{Source.Materials.Payette\PYGZus{}build\PYGZus{}material} \PYG{k+kn}{import} \PYG{n}{MaterialBuilder}

\PYG{k}{class} \PYG{n+nc}{Build}\PYG{p}{(}\PYG{n}{MaterialBuilder}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{def} \PYG{n+nf}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{name}\PYG{p}{,}\PYG{n}{libname}\PYG{p}{,}\PYG{n}{compiler\PYGZus{}info}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{fdir}\PYG{p}{,}\PYG{n}{fnam} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{realpath}\PYG{p}{(}\PYG{n}{\PYGZus{}\PYGZus{}file\PYGZus{}\PYGZus{}}\PYG{p}{)}\PYG{p}{)}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fdir}\PYG{p}{,} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fnam} \PYG{o}{=} \PYG{n}{fdir}\PYG{p}{,} \PYG{n}{fnam}

        \PYG{c}{\PYGZsh{} initialize base class}
        \PYG{n}{MaterialBuilder}\PYG{o}{.}\PYG{n}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,}\PYG{n}{name}\PYG{p}{,}\PYG{n}{libname}\PYG{p}{,}\PYG{n}{fdir}\PYG{p}{,}\PYG{n}{compiler\PYGZus{}info}\PYG{p}{)}

        \PYG{k}{pass}

    \PYG{k}{def} \PYG{n+nf}{build\PYGZus{}extension\PYGZus{}module}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{)}\PYG{p}{:}

        \PYG{c}{\PYGZsh{} fortran files}
        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{source\PYGZus{}files} \PYG{o}{=} \PYG{p}{[}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fdir}\PYG{p}{,}\PYG{n}{x}\PYG{p}{)} \PYG{k}{for} \PYG{n}{x} \PYG{o+ow}{in} \PYG{n}{os}\PYG{o}{.}\PYG{n}{listdir}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{fdir}\PYG{p}{)}
                             \PYG{k}{if} \PYG{n}{x}\PYG{o}{.}\PYG{n}{endswith}\PYG{p}{(}\PYG{l+s}{"}\PYG{l+s}{.F}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{]}

        \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{build\PYGZus{}extension\PYGZus{}module\PYGZus{}with\PYGZus{}f2py}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{return} \PYG{l+m+mi}{0}
\end{Verbatim}

\begin{notice}{note}{Note:}
For the elastic material, the \code{build\_extension\_module} function defines the
Fortran source files and the calls the base class's
\code{build\_extension\_module\_with\_f2py} function.
\end{notice}


\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
